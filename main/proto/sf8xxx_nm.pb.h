// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sf8xxx_nm.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sf8xxx_5fnm_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sf8xxx_5fnm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sf8xxx_5fnm_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sf8xxx_5fnm_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace sf8xxx_nm {
class ActionCommand;
struct ActionCommandDefaultTypeInternal;
extern ActionCommandDefaultTypeInternal _ActionCommand_default_instance_;
class ConfigureCommand;
struct ConfigureCommandDefaultTypeInternal;
extern ConfigureCommandDefaultTypeInternal _ConfigureCommand_default_instance_;
class DriverCommand;
struct DriverCommandDefaultTypeInternal;
extern DriverCommandDefaultTypeInternal _DriverCommand_default_instance_;
class DriverResponse;
struct DriverResponseDefaultTypeInternal;
extern DriverResponseDefaultTypeInternal _DriverResponse_default_instance_;
class DriverStateInfo;
struct DriverStateInfoDefaultTypeInternal;
extern DriverStateInfoDefaultTypeInternal _DriverStateInfo_default_instance_;
class DriverStateSettings;
struct DriverStateSettingsDefaultTypeInternal;
extern DriverStateSettingsDefaultTypeInternal _DriverStateSettings_default_instance_;
class LddSettings;
struct LddSettingsDefaultTypeInternal;
extern LddSettingsDefaultTypeInternal _LddSettings_default_instance_;
class LddStatus;
struct LddStatusDefaultTypeInternal;
extern LddStatusDefaultTypeInternal _LddStatus_default_instance_;
class LockStatusInfo;
struct LockStatusInfoDefaultTypeInternal;
extern LockStatusInfoDefaultTypeInternal _LockStatusInfo_default_instance_;
class NtcInterlockSettings;
struct NtcInterlockSettingsDefaultTypeInternal;
extern NtcInterlockSettingsDefaultTypeInternal _NtcInterlockSettings_default_instance_;
class PidSettings;
struct PidSettingsDefaultTypeInternal;
extern PidSettingsDefaultTypeInternal _PidSettings_default_instance_;
class RequestCommand;
struct RequestCommandDefaultTypeInternal;
extern RequestCommandDefaultTypeInternal _RequestCommand_default_instance_;
class TecSettings;
struct TecSettingsDefaultTypeInternal;
extern TecSettingsDefaultTypeInternal _TecSettings_default_instance_;
class TecStateInfo;
struct TecStateInfoDefaultTypeInternal;
extern TecStateInfoDefaultTypeInternal _TecStateInfo_default_instance_;
class TecStateSettings;
struct TecStateSettingsDefaultTypeInternal;
extern TecStateSettingsDefaultTypeInternal _TecStateSettings_default_instance_;
class TecStatus;
struct TecStatusDefaultTypeInternal;
extern TecStatusDefaultTypeInternal _TecStatus_default_instance_;
}  // namespace sf8xxx_nm
PROTOBUF_NAMESPACE_OPEN
template<> ::sf8xxx_nm::ActionCommand* Arena::CreateMaybeMessage<::sf8xxx_nm::ActionCommand>(Arena*);
template<> ::sf8xxx_nm::ConfigureCommand* Arena::CreateMaybeMessage<::sf8xxx_nm::ConfigureCommand>(Arena*);
template<> ::sf8xxx_nm::DriverCommand* Arena::CreateMaybeMessage<::sf8xxx_nm::DriverCommand>(Arena*);
template<> ::sf8xxx_nm::DriverResponse* Arena::CreateMaybeMessage<::sf8xxx_nm::DriverResponse>(Arena*);
template<> ::sf8xxx_nm::DriverStateInfo* Arena::CreateMaybeMessage<::sf8xxx_nm::DriverStateInfo>(Arena*);
template<> ::sf8xxx_nm::DriverStateSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::DriverStateSettings>(Arena*);
template<> ::sf8xxx_nm::LddSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::LddSettings>(Arena*);
template<> ::sf8xxx_nm::LddStatus* Arena::CreateMaybeMessage<::sf8xxx_nm::LddStatus>(Arena*);
template<> ::sf8xxx_nm::LockStatusInfo* Arena::CreateMaybeMessage<::sf8xxx_nm::LockStatusInfo>(Arena*);
template<> ::sf8xxx_nm::NtcInterlockSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::NtcInterlockSettings>(Arena*);
template<> ::sf8xxx_nm::PidSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::PidSettings>(Arena*);
template<> ::sf8xxx_nm::RequestCommand* Arena::CreateMaybeMessage<::sf8xxx_nm::RequestCommand>(Arena*);
template<> ::sf8xxx_nm::TecSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::TecSettings>(Arena*);
template<> ::sf8xxx_nm::TecStateInfo* Arena::CreateMaybeMessage<::sf8xxx_nm::TecStateInfo>(Arena*);
template<> ::sf8xxx_nm::TecStateSettings* Arena::CreateMaybeMessage<::sf8xxx_nm::TecStateSettings>(Arena*);
template<> ::sf8xxx_nm::TecStatus* Arena::CreateMaybeMessage<::sf8xxx_nm::TecStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sf8xxx_nm {

enum DriverStateSettings_CurrentSetSource : int {
  DriverStateSettings_CurrentSetSource_CURRENT_SET_SOURCE_UNSPECIFIED = 0,
  DriverStateSettings_CurrentSetSource_EXTERNAL = 1,
  DriverStateSettings_CurrentSetSource_INTERNAL = 2,
  DriverStateSettings_CurrentSetSource_DriverStateSettings_CurrentSetSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriverStateSettings_CurrentSetSource_DriverStateSettings_CurrentSetSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriverStateSettings_CurrentSetSource_IsValid(int value);
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings_CurrentSetSource_CurrentSetSource_MIN = DriverStateSettings_CurrentSetSource_CURRENT_SET_SOURCE_UNSPECIFIED;
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings_CurrentSetSource_CurrentSetSource_MAX = DriverStateSettings_CurrentSetSource_INTERNAL;
constexpr int DriverStateSettings_CurrentSetSource_CurrentSetSource_ARRAYSIZE = DriverStateSettings_CurrentSetSource_CurrentSetSource_MAX + 1;

const std::string& DriverStateSettings_CurrentSetSource_Name(DriverStateSettings_CurrentSetSource value);
template<typename T>
inline const std::string& DriverStateSettings_CurrentSetSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriverStateSettings_CurrentSetSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriverStateSettings_CurrentSetSource_Name.");
  return DriverStateSettings_CurrentSetSource_Name(static_cast<DriverStateSettings_CurrentSetSource>(enum_t_value));
}
bool DriverStateSettings_CurrentSetSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_CurrentSetSource* value);
enum DriverStateSettings_EnableSource : int {
  DriverStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED = 0,
  DriverStateSettings_EnableSource_EXTERNAL_PIN = 1,
  DriverStateSettings_EnableSource_INTERNAL_CMD = 2,
  DriverStateSettings_EnableSource_DriverStateSettings_EnableSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriverStateSettings_EnableSource_DriverStateSettings_EnableSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriverStateSettings_EnableSource_IsValid(int value);
constexpr DriverStateSettings_EnableSource DriverStateSettings_EnableSource_EnableSource_MIN = DriverStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED;
constexpr DriverStateSettings_EnableSource DriverStateSettings_EnableSource_EnableSource_MAX = DriverStateSettings_EnableSource_INTERNAL_CMD;
constexpr int DriverStateSettings_EnableSource_EnableSource_ARRAYSIZE = DriverStateSettings_EnableSource_EnableSource_MAX + 1;

const std::string& DriverStateSettings_EnableSource_Name(DriverStateSettings_EnableSource value);
template<typename T>
inline const std::string& DriverStateSettings_EnableSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriverStateSettings_EnableSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriverStateSettings_EnableSource_Name.");
  return DriverStateSettings_EnableSource_Name(static_cast<DriverStateSettings_EnableSource>(enum_t_value));
}
bool DriverStateSettings_EnableSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_EnableSource* value);
enum DriverStateSettings_InterlockPolicy : int {
  DriverStateSettings_InterlockPolicy_INTERLOCK_POLICY_UNSPECIFIED = 0,
  DriverStateSettings_InterlockPolicy_ALLOW = 1,
  DriverStateSettings_InterlockPolicy_DENY = 2,
  DriverStateSettings_InterlockPolicy_DriverStateSettings_InterlockPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriverStateSettings_InterlockPolicy_DriverStateSettings_InterlockPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriverStateSettings_InterlockPolicy_IsValid(int value);
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings_InterlockPolicy_InterlockPolicy_MIN = DriverStateSettings_InterlockPolicy_INTERLOCK_POLICY_UNSPECIFIED;
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings_InterlockPolicy_InterlockPolicy_MAX = DriverStateSettings_InterlockPolicy_DENY;
constexpr int DriverStateSettings_InterlockPolicy_InterlockPolicy_ARRAYSIZE = DriverStateSettings_InterlockPolicy_InterlockPolicy_MAX + 1;

const std::string& DriverStateSettings_InterlockPolicy_Name(DriverStateSettings_InterlockPolicy value);
template<typename T>
inline const std::string& DriverStateSettings_InterlockPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriverStateSettings_InterlockPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriverStateSettings_InterlockPolicy_Name.");
  return DriverStateSettings_InterlockPolicy_Name(static_cast<DriverStateSettings_InterlockPolicy>(enum_t_value));
}
bool DriverStateSettings_InterlockPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_InterlockPolicy* value);
enum DriverStateSettings_NtcInterlockPolicy : int {
  DriverStateSettings_NtcInterlockPolicy_NTC_INTERLOCK_POLICY_UNSPECIFIED = 0,
  DriverStateSettings_NtcInterlockPolicy_ALLOW_NTC = 1,
  DriverStateSettings_NtcInterlockPolicy_DENY_NTC = 2,
  DriverStateSettings_NtcInterlockPolicy_DriverStateSettings_NtcInterlockPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DriverStateSettings_NtcInterlockPolicy_DriverStateSettings_NtcInterlockPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DriverStateSettings_NtcInterlockPolicy_IsValid(int value);
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_MIN = DriverStateSettings_NtcInterlockPolicy_NTC_INTERLOCK_POLICY_UNSPECIFIED;
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_MAX = DriverStateSettings_NtcInterlockPolicy_DENY_NTC;
constexpr int DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_ARRAYSIZE = DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_MAX + 1;

const std::string& DriverStateSettings_NtcInterlockPolicy_Name(DriverStateSettings_NtcInterlockPolicy value);
template<typename T>
inline const std::string& DriverStateSettings_NtcInterlockPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DriverStateSettings_NtcInterlockPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DriverStateSettings_NtcInterlockPolicy_Name.");
  return DriverStateSettings_NtcInterlockPolicy_Name(static_cast<DriverStateSettings_NtcInterlockPolicy>(enum_t_value));
}
bool DriverStateSettings_NtcInterlockPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_NtcInterlockPolicy* value);
enum TecStateSettings_TempSetSource : int {
  TecStateSettings_TempSetSource_TEMP_SET_SOURCE_UNSPECIFIED = 0,
  TecStateSettings_TempSetSource_EXTERNAL = 1,
  TecStateSettings_TempSetSource_INTERNAL = 2,
  TecStateSettings_TempSetSource_TecStateSettings_TempSetSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TecStateSettings_TempSetSource_TecStateSettings_TempSetSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TecStateSettings_TempSetSource_IsValid(int value);
constexpr TecStateSettings_TempSetSource TecStateSettings_TempSetSource_TempSetSource_MIN = TecStateSettings_TempSetSource_TEMP_SET_SOURCE_UNSPECIFIED;
constexpr TecStateSettings_TempSetSource TecStateSettings_TempSetSource_TempSetSource_MAX = TecStateSettings_TempSetSource_INTERNAL;
constexpr int TecStateSettings_TempSetSource_TempSetSource_ARRAYSIZE = TecStateSettings_TempSetSource_TempSetSource_MAX + 1;

const std::string& TecStateSettings_TempSetSource_Name(TecStateSettings_TempSetSource value);
template<typename T>
inline const std::string& TecStateSettings_TempSetSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TecStateSettings_TempSetSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TecStateSettings_TempSetSource_Name.");
  return TecStateSettings_TempSetSource_Name(static_cast<TecStateSettings_TempSetSource>(enum_t_value));
}
bool TecStateSettings_TempSetSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TecStateSettings_TempSetSource* value);
enum TecStateSettings_EnableSource : int {
  TecStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED = 0,
  TecStateSettings_EnableSource_EXTERNAL_PIN = 1,
  TecStateSettings_EnableSource_INTERNAL_CMD = 2,
  TecStateSettings_EnableSource_TecStateSettings_EnableSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TecStateSettings_EnableSource_TecStateSettings_EnableSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TecStateSettings_EnableSource_IsValid(int value);
constexpr TecStateSettings_EnableSource TecStateSettings_EnableSource_EnableSource_MIN = TecStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED;
constexpr TecStateSettings_EnableSource TecStateSettings_EnableSource_EnableSource_MAX = TecStateSettings_EnableSource_INTERNAL_CMD;
constexpr int TecStateSettings_EnableSource_EnableSource_ARRAYSIZE = TecStateSettings_EnableSource_EnableSource_MAX + 1;

const std::string& TecStateSettings_EnableSource_Name(TecStateSettings_EnableSource value);
template<typename T>
inline const std::string& TecStateSettings_EnableSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TecStateSettings_EnableSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TecStateSettings_EnableSource_Name.");
  return TecStateSettings_EnableSource_Name(static_cast<TecStateSettings_EnableSource>(enum_t_value));
}
bool TecStateSettings_EnableSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TecStateSettings_EnableSource* value);
enum RequestType : int {
  REQ_UNSPECIFIED = 0,
  REQ_LDD_STATUS_ALL = 1,
  REQ_FREQUENCY_HZ = 2,
  REQ_FREQUENCY_MIN_HZ = 3,
  REQ_FREQUENCY_MAX_HZ = 4,
  REQ_DURATION_MS = 5,
  REQ_DURATION_MIN_MS = 6,
  REQ_DURATION_MAX_MS = 7,
  REQ_CURRENT_MA = 8,
  REQ_CURRENT_MIN_MA = 9,
  REQ_CURRENT_MAX_MA = 10,
  REQ_CURRENT_MAX_LIMIT_MA = 11,
  REQ_MEASURED_CURRENT_MA = 12,
  REQ_CURRENT_PROTECTION_THRESHOLD_MA = 13,
  REQ_CURRENT_CALIBRATION_PERCENT = 14,
  REQ_MEASURED_VOLTAGE_V = 15,
  REQ_TEC_STATUS_ALL = 20,
  REQ_TEC_TEMPERATURE_CELSIUS = 21,
  REQ_TEC_TEMPERATURE_MAX_CELSIUS = 22,
  REQ_TEC_TEMPERATURE_MIN_CELSIUS = 23,
  REQ_TEC_TEMPERATURE_MAX_LIMIT_CELSIUS = 24,
  REQ_TEC_TEMPERATURE_MIN_LIMIT_CELSIUS = 25,
  REQ_TEC_MEASURED_TEMPERATURE_CELSIUS = 26,
  REQ_TEC_MEASURED_CURRENT_A = 27,
  REQ_TEC_CURRENT_LIMIT_A = 28,
  REQ_TEC_MEASURED_VOLTAGE_V = 29,
  REQ_TEC_CALIBRATION_PERCENT = 30,
  REQ_PID_COEFFICIENTS = 40,
  REQ_EXTERNAL_NTC_ALL = 50,
  REQ_EXTERNAL_NTC_LOWER_LIMIT_CELSIUS = 51,
  REQ_EXTERNAL_NTC_UPPER_LIMIT_CELSIUS = 52,
  REQ_EXTERNAL_NTC_MEASURED_TEMP_CELSIUS = 53,
  REQ_DRIVER_STATE = 60,
  REQ_TEC_STATE = 61,
  REQ_LOCK_STATUS = 62,
  REQ_SERIAL_NUMBER = 63,
  RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RequestType_IsValid(int value);
constexpr RequestType RequestType_MIN = REQ_UNSPECIFIED;
constexpr RequestType RequestType_MAX = REQ_SERIAL_NUMBER;
constexpr int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const std::string& RequestType_Name(RequestType value);
template<typename T>
inline const std::string& RequestType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestType_Name.");
  return RequestType_Name(static_cast<RequestType>(enum_t_value));
}
bool RequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestType* value);
enum ActionType : int {
  ACTION_UNSPECIFIED = 0,
  START_DRIVER = 1,
  STOP_DRIVER = 2,
  START_TEC = 3,
  STOP_TEC = 4,
  SAVE_PARAMETERS = 5,
  RESET_PARAMETERS = 6,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = ACTION_UNSPECIFIED;
constexpr ActionType ActionType_MAX = RESET_PARAMETERS;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const std::string& ActionType_Name(ActionType value);
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ActionType_Name(static_cast<ActionType>(enum_t_value));
}
bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value);
enum ErrorCode : int {
  ERROR_UNSPECIFIED = 0,
  ERROR_SERIAL_PROTOCOL = 1,
  ERROR_PARAMETER_OUT_OF_RANGE = 2,
  ERROR_UNKNOWN_COMMAND = 3,
  ERROR_INTERNAL_PROBLEM = 4,
  ERROR_LD_OVERCURRENT = 5,
  ERROR_LD_OVERHEAT = 6,
  ERROR_EXTERNAL_NTC_INTERLOCK = 7,
  ERROR_TEC_ERROR = 8,
  ERROR_TEC_SELF_HEAT = 9,
  ERROR_INTERLOCK_INPUT = 10,
  ERROR_FIRMWARE_UPDATE = 11,
  ERROR_NO_LD_CONNECTED = 12,
  ERROR_NO_EXTERNAL_NTC_CONNECTED = 13,
  ERROR_COMMUNICATION_TIMEOUT = 14,
  ERROR_PARSE = 15,
  ERROR_RESERVED = 16,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = ERROR_UNSPECIFIED;
constexpr ErrorCode ErrorCode_MAX = ERROR_RESERVED;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const std::string& ErrorCode_Name(ErrorCode value);
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ErrorCode_Name(static_cast<ErrorCode>(enum_t_value));
}
bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value);
// ===================================================================

class DriverCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.DriverCommand) */ {
 public:
  inline DriverCommand() : DriverCommand(nullptr) {}
  virtual ~DriverCommand();
  explicit constexpr DriverCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriverCommand(const DriverCommand& from);
  DriverCommand(DriverCommand&& from) noexcept
    : DriverCommand() {
    *this = ::std::move(from);
  }

  inline DriverCommand& operator=(const DriverCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriverCommand& operator=(DriverCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriverCommand& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kConfigure = 1,
    kRequest = 2,
    kAction = 3,
    COMMAND_NOT_SET = 0,
  };

  static inline const DriverCommand* internal_default_instance() {
    return reinterpret_cast<const DriverCommand*>(
               &_DriverCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DriverCommand& a, DriverCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DriverCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriverCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DriverCommand* New() const final {
    return CreateMaybeMessage<DriverCommand>(nullptr);
  }

  DriverCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DriverCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DriverCommand& from);
  void MergeFrom(const DriverCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriverCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.DriverCommand";
  }
  protected:
  explicit DriverCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigureFieldNumber = 1,
    kRequestFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // .sf8xxx_nm.ConfigureCommand configure = 1;
  bool has_configure() const;
  private:
  bool _internal_has_configure() const;
  public:
  void clear_configure();
  const ::sf8xxx_nm::ConfigureCommand& configure() const;
  ::sf8xxx_nm::ConfigureCommand* release_configure();
  ::sf8xxx_nm::ConfigureCommand* mutable_configure();
  void set_allocated_configure(::sf8xxx_nm::ConfigureCommand* configure);
  private:
  const ::sf8xxx_nm::ConfigureCommand& _internal_configure() const;
  ::sf8xxx_nm::ConfigureCommand* _internal_mutable_configure();
  public:
  void unsafe_arena_set_allocated_configure(
      ::sf8xxx_nm::ConfigureCommand* configure);
  ::sf8xxx_nm::ConfigureCommand* unsafe_arena_release_configure();

  // .sf8xxx_nm.RequestCommand request = 2;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::sf8xxx_nm::RequestCommand& request() const;
  ::sf8xxx_nm::RequestCommand* release_request();
  ::sf8xxx_nm::RequestCommand* mutable_request();
  void set_allocated_request(::sf8xxx_nm::RequestCommand* request);
  private:
  const ::sf8xxx_nm::RequestCommand& _internal_request() const;
  ::sf8xxx_nm::RequestCommand* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::sf8xxx_nm::RequestCommand* request);
  ::sf8xxx_nm::RequestCommand* unsafe_arena_release_request();

  // .sf8xxx_nm.ActionCommand action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::sf8xxx_nm::ActionCommand& action() const;
  ::sf8xxx_nm::ActionCommand* release_action();
  ::sf8xxx_nm::ActionCommand* mutable_action();
  void set_allocated_action(::sf8xxx_nm::ActionCommand* action);
  private:
  const ::sf8xxx_nm::ActionCommand& _internal_action() const;
  ::sf8xxx_nm::ActionCommand* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::sf8xxx_nm::ActionCommand* action);
  ::sf8xxx_nm::ActionCommand* unsafe_arena_release_action();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:sf8xxx_nm.DriverCommand)
 private:
  class _Internal;
  void set_has_configure();
  void set_has_request();
  void set_has_action();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union CommandUnion {
    constexpr CommandUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sf8xxx_nm::ConfigureCommand* configure_;
    ::sf8xxx_nm::RequestCommand* request_;
    ::sf8xxx_nm::ActionCommand* action_;
  } command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class DriverResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.DriverResponse) */ {
 public:
  inline DriverResponse() : DriverResponse(nullptr) {}
  virtual ~DriverResponse();
  explicit constexpr DriverResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriverResponse(const DriverResponse& from);
  DriverResponse(DriverResponse&& from) noexcept
    : DriverResponse() {
    *this = ::std::move(from);
  }

  inline DriverResponse& operator=(const DriverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriverResponse& operator=(DriverResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriverResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriverResponse* internal_default_instance() {
    return reinterpret_cast<const DriverResponse*>(
               &_DriverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DriverResponse& a, DriverResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DriverResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriverResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DriverResponse* New() const final {
    return CreateMaybeMessage<DriverResponse>(nullptr);
  }

  DriverResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DriverResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DriverResponse& from);
  void MergeFrom(const DriverResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriverResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.DriverResponse";
  }
  protected:
  explicit DriverResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLddStatusFieldNumber = 2,
    kTecStatusFieldNumber = 3,
    kDriverStateFieldNumber = 4,
    kTecStateFieldNumber = 5,
    kLockStatusFieldNumber = 6,
    kErrorCodeFieldNumber = 1,
    kSerialNumberFieldNumber = 7,
  };
  // .sf8xxx_nm.LddStatus ldd_status = 2;
  bool has_ldd_status() const;
  private:
  bool _internal_has_ldd_status() const;
  public:
  void clear_ldd_status();
  const ::sf8xxx_nm::LddStatus& ldd_status() const;
  ::sf8xxx_nm::LddStatus* release_ldd_status();
  ::sf8xxx_nm::LddStatus* mutable_ldd_status();
  void set_allocated_ldd_status(::sf8xxx_nm::LddStatus* ldd_status);
  private:
  const ::sf8xxx_nm::LddStatus& _internal_ldd_status() const;
  ::sf8xxx_nm::LddStatus* _internal_mutable_ldd_status();
  public:
  void unsafe_arena_set_allocated_ldd_status(
      ::sf8xxx_nm::LddStatus* ldd_status);
  ::sf8xxx_nm::LddStatus* unsafe_arena_release_ldd_status();

  // .sf8xxx_nm.TecStatus tec_status = 3;
  bool has_tec_status() const;
  private:
  bool _internal_has_tec_status() const;
  public:
  void clear_tec_status();
  const ::sf8xxx_nm::TecStatus& tec_status() const;
  ::sf8xxx_nm::TecStatus* release_tec_status();
  ::sf8xxx_nm::TecStatus* mutable_tec_status();
  void set_allocated_tec_status(::sf8xxx_nm::TecStatus* tec_status);
  private:
  const ::sf8xxx_nm::TecStatus& _internal_tec_status() const;
  ::sf8xxx_nm::TecStatus* _internal_mutable_tec_status();
  public:
  void unsafe_arena_set_allocated_tec_status(
      ::sf8xxx_nm::TecStatus* tec_status);
  ::sf8xxx_nm::TecStatus* unsafe_arena_release_tec_status();

  // .sf8xxx_nm.DriverStateInfo driver_state = 4;
  bool has_driver_state() const;
  private:
  bool _internal_has_driver_state() const;
  public:
  void clear_driver_state();
  const ::sf8xxx_nm::DriverStateInfo& driver_state() const;
  ::sf8xxx_nm::DriverStateInfo* release_driver_state();
  ::sf8xxx_nm::DriverStateInfo* mutable_driver_state();
  void set_allocated_driver_state(::sf8xxx_nm::DriverStateInfo* driver_state);
  private:
  const ::sf8xxx_nm::DriverStateInfo& _internal_driver_state() const;
  ::sf8xxx_nm::DriverStateInfo* _internal_mutable_driver_state();
  public:
  void unsafe_arena_set_allocated_driver_state(
      ::sf8xxx_nm::DriverStateInfo* driver_state);
  ::sf8xxx_nm::DriverStateInfo* unsafe_arena_release_driver_state();

  // .sf8xxx_nm.TecStateInfo tec_state = 5;
  bool has_tec_state() const;
  private:
  bool _internal_has_tec_state() const;
  public:
  void clear_tec_state();
  const ::sf8xxx_nm::TecStateInfo& tec_state() const;
  ::sf8xxx_nm::TecStateInfo* release_tec_state();
  ::sf8xxx_nm::TecStateInfo* mutable_tec_state();
  void set_allocated_tec_state(::sf8xxx_nm::TecStateInfo* tec_state);
  private:
  const ::sf8xxx_nm::TecStateInfo& _internal_tec_state() const;
  ::sf8xxx_nm::TecStateInfo* _internal_mutable_tec_state();
  public:
  void unsafe_arena_set_allocated_tec_state(
      ::sf8xxx_nm::TecStateInfo* tec_state);
  ::sf8xxx_nm::TecStateInfo* unsafe_arena_release_tec_state();

  // .sf8xxx_nm.LockStatusInfo lock_status = 6;
  bool has_lock_status() const;
  private:
  bool _internal_has_lock_status() const;
  public:
  void clear_lock_status();
  const ::sf8xxx_nm::LockStatusInfo& lock_status() const;
  ::sf8xxx_nm::LockStatusInfo* release_lock_status();
  ::sf8xxx_nm::LockStatusInfo* mutable_lock_status();
  void set_allocated_lock_status(::sf8xxx_nm::LockStatusInfo* lock_status);
  private:
  const ::sf8xxx_nm::LockStatusInfo& _internal_lock_status() const;
  ::sf8xxx_nm::LockStatusInfo* _internal_mutable_lock_status();
  public:
  void unsafe_arena_set_allocated_lock_status(
      ::sf8xxx_nm::LockStatusInfo* lock_status);
  ::sf8xxx_nm::LockStatusInfo* unsafe_arena_release_lock_status();

  // .sf8xxx_nm.ErrorCode error_code = 1;
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::sf8xxx_nm::ErrorCode error_code() const;
  void set_error_code(::sf8xxx_nm::ErrorCode value);
  private:
  ::sf8xxx_nm::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::sf8xxx_nm::ErrorCode value);
  public:

  // uint32 serial_number = 7;
  bool has_serial_number() const;
  private:
  bool _internal_has_serial_number() const;
  public:
  void clear_serial_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 serial_number() const;
  void set_serial_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_serial_number() const;
  void _internal_set_serial_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.DriverResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::sf8xxx_nm::LddStatus* ldd_status_;
  ::sf8xxx_nm::TecStatus* tec_status_;
  ::sf8xxx_nm::DriverStateInfo* driver_state_;
  ::sf8xxx_nm::TecStateInfo* tec_state_;
  ::sf8xxx_nm::LockStatusInfo* lock_status_;
  int error_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 serial_number_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class ConfigureCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.ConfigureCommand) */ {
 public:
  inline ConfigureCommand() : ConfigureCommand(nullptr) {}
  virtual ~ConfigureCommand();
  explicit constexpr ConfigureCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureCommand(const ConfigureCommand& from);
  ConfigureCommand(ConfigureCommand&& from) noexcept
    : ConfigureCommand() {
    *this = ::std::move(from);
  }

  inline ConfigureCommand& operator=(const ConfigureCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureCommand& operator=(ConfigureCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ConfigureCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureCommand* internal_default_instance() {
    return reinterpret_cast<const ConfigureCommand*>(
               &_ConfigureCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ConfigureCommand& a, ConfigureCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigureCommand* New() const final {
    return CreateMaybeMessage<ConfigureCommand>(nullptr);
  }

  ConfigureCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigureCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ConfigureCommand& from);
  void MergeFrom(const ConfigureCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConfigureCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.ConfigureCommand";
  }
  protected:
  explicit ConfigureCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLddSettingsFieldNumber = 1,
    kTecSettingsFieldNumber = 2,
    kPidSettingsFieldNumber = 3,
    kNtcInterlockSettingsFieldNumber = 4,
    kDriverStateSettingsFieldNumber = 5,
    kTecStateSettingsFieldNumber = 6,
  };
  // .sf8xxx_nm.LddSettings ldd_settings = 1;
  bool has_ldd_settings() const;
  private:
  bool _internal_has_ldd_settings() const;
  public:
  void clear_ldd_settings();
  const ::sf8xxx_nm::LddSettings& ldd_settings() const;
  ::sf8xxx_nm::LddSettings* release_ldd_settings();
  ::sf8xxx_nm::LddSettings* mutable_ldd_settings();
  void set_allocated_ldd_settings(::sf8xxx_nm::LddSettings* ldd_settings);
  private:
  const ::sf8xxx_nm::LddSettings& _internal_ldd_settings() const;
  ::sf8xxx_nm::LddSettings* _internal_mutable_ldd_settings();
  public:
  void unsafe_arena_set_allocated_ldd_settings(
      ::sf8xxx_nm::LddSettings* ldd_settings);
  ::sf8xxx_nm::LddSettings* unsafe_arena_release_ldd_settings();

  // .sf8xxx_nm.TecSettings tec_settings = 2;
  bool has_tec_settings() const;
  private:
  bool _internal_has_tec_settings() const;
  public:
  void clear_tec_settings();
  const ::sf8xxx_nm::TecSettings& tec_settings() const;
  ::sf8xxx_nm::TecSettings* release_tec_settings();
  ::sf8xxx_nm::TecSettings* mutable_tec_settings();
  void set_allocated_tec_settings(::sf8xxx_nm::TecSettings* tec_settings);
  private:
  const ::sf8xxx_nm::TecSettings& _internal_tec_settings() const;
  ::sf8xxx_nm::TecSettings* _internal_mutable_tec_settings();
  public:
  void unsafe_arena_set_allocated_tec_settings(
      ::sf8xxx_nm::TecSettings* tec_settings);
  ::sf8xxx_nm::TecSettings* unsafe_arena_release_tec_settings();

  // .sf8xxx_nm.PidSettings pid_settings = 3;
  bool has_pid_settings() const;
  private:
  bool _internal_has_pid_settings() const;
  public:
  void clear_pid_settings();
  const ::sf8xxx_nm::PidSettings& pid_settings() const;
  ::sf8xxx_nm::PidSettings* release_pid_settings();
  ::sf8xxx_nm::PidSettings* mutable_pid_settings();
  void set_allocated_pid_settings(::sf8xxx_nm::PidSettings* pid_settings);
  private:
  const ::sf8xxx_nm::PidSettings& _internal_pid_settings() const;
  ::sf8xxx_nm::PidSettings* _internal_mutable_pid_settings();
  public:
  void unsafe_arena_set_allocated_pid_settings(
      ::sf8xxx_nm::PidSettings* pid_settings);
  ::sf8xxx_nm::PidSettings* unsafe_arena_release_pid_settings();

  // .sf8xxx_nm.NtcInterlockSettings ntc_interlock_settings = 4;
  bool has_ntc_interlock_settings() const;
  private:
  bool _internal_has_ntc_interlock_settings() const;
  public:
  void clear_ntc_interlock_settings();
  const ::sf8xxx_nm::NtcInterlockSettings& ntc_interlock_settings() const;
  ::sf8xxx_nm::NtcInterlockSettings* release_ntc_interlock_settings();
  ::sf8xxx_nm::NtcInterlockSettings* mutable_ntc_interlock_settings();
  void set_allocated_ntc_interlock_settings(::sf8xxx_nm::NtcInterlockSettings* ntc_interlock_settings);
  private:
  const ::sf8xxx_nm::NtcInterlockSettings& _internal_ntc_interlock_settings() const;
  ::sf8xxx_nm::NtcInterlockSettings* _internal_mutable_ntc_interlock_settings();
  public:
  void unsafe_arena_set_allocated_ntc_interlock_settings(
      ::sf8xxx_nm::NtcInterlockSettings* ntc_interlock_settings);
  ::sf8xxx_nm::NtcInterlockSettings* unsafe_arena_release_ntc_interlock_settings();

  // .sf8xxx_nm.DriverStateSettings driver_state_settings = 5;
  bool has_driver_state_settings() const;
  private:
  bool _internal_has_driver_state_settings() const;
  public:
  void clear_driver_state_settings();
  const ::sf8xxx_nm::DriverStateSettings& driver_state_settings() const;
  ::sf8xxx_nm::DriverStateSettings* release_driver_state_settings();
  ::sf8xxx_nm::DriverStateSettings* mutable_driver_state_settings();
  void set_allocated_driver_state_settings(::sf8xxx_nm::DriverStateSettings* driver_state_settings);
  private:
  const ::sf8xxx_nm::DriverStateSettings& _internal_driver_state_settings() const;
  ::sf8xxx_nm::DriverStateSettings* _internal_mutable_driver_state_settings();
  public:
  void unsafe_arena_set_allocated_driver_state_settings(
      ::sf8xxx_nm::DriverStateSettings* driver_state_settings);
  ::sf8xxx_nm::DriverStateSettings* unsafe_arena_release_driver_state_settings();

  // .sf8xxx_nm.TecStateSettings tec_state_settings = 6;
  bool has_tec_state_settings() const;
  private:
  bool _internal_has_tec_state_settings() const;
  public:
  void clear_tec_state_settings();
  const ::sf8xxx_nm::TecStateSettings& tec_state_settings() const;
  ::sf8xxx_nm::TecStateSettings* release_tec_state_settings();
  ::sf8xxx_nm::TecStateSettings* mutable_tec_state_settings();
  void set_allocated_tec_state_settings(::sf8xxx_nm::TecStateSettings* tec_state_settings);
  private:
  const ::sf8xxx_nm::TecStateSettings& _internal_tec_state_settings() const;
  ::sf8xxx_nm::TecStateSettings* _internal_mutable_tec_state_settings();
  public:
  void unsafe_arena_set_allocated_tec_state_settings(
      ::sf8xxx_nm::TecStateSettings* tec_state_settings);
  ::sf8xxx_nm::TecStateSettings* unsafe_arena_release_tec_state_settings();

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.ConfigureCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::sf8xxx_nm::LddSettings* ldd_settings_;
  ::sf8xxx_nm::TecSettings* tec_settings_;
  ::sf8xxx_nm::PidSettings* pid_settings_;
  ::sf8xxx_nm::NtcInterlockSettings* ntc_interlock_settings_;
  ::sf8xxx_nm::DriverStateSettings* driver_state_settings_;
  ::sf8xxx_nm::TecStateSettings* tec_state_settings_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class LddSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.LddSettings) */ {
 public:
  inline LddSettings() : LddSettings(nullptr) {}
  virtual ~LddSettings();
  explicit constexpr LddSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LddSettings(const LddSettings& from);
  LddSettings(LddSettings&& from) noexcept
    : LddSettings() {
    *this = ::std::move(from);
  }

  inline LddSettings& operator=(const LddSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline LddSettings& operator=(LddSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LddSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const LddSettings* internal_default_instance() {
    return reinterpret_cast<const LddSettings*>(
               &_LddSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LddSettings& a, LddSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(LddSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LddSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LddSettings* New() const final {
    return CreateMaybeMessage<LddSettings>(nullptr);
  }

  LddSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LddSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LddSettings& from);
  void MergeFrom(const LddSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LddSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.LddSettings";
  }
  protected:
  explicit LddSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyHzFieldNumber = 1,
    kDurationMsFieldNumber = 2,
    kCurrentMaFieldNumber = 3,
    kCurrentMaxMaFieldNumber = 4,
    kCurrentCalibrationPercentFieldNumber = 5,
  };
  // float frequency_hz = 1;
  bool has_frequency_hz() const;
  private:
  bool _internal_has_frequency_hz() const;
  public:
  void clear_frequency_hz();
  float frequency_hz() const;
  void set_frequency_hz(float value);
  private:
  float _internal_frequency_hz() const;
  void _internal_set_frequency_hz(float value);
  public:

  // float duration_ms = 2;
  bool has_duration_ms() const;
  private:
  bool _internal_has_duration_ms() const;
  public:
  void clear_duration_ms();
  float duration_ms() const;
  void set_duration_ms(float value);
  private:
  float _internal_duration_ms() const;
  void _internal_set_duration_ms(float value);
  public:

  // float current_ma = 3;
  bool has_current_ma() const;
  private:
  bool _internal_has_current_ma() const;
  public:
  void clear_current_ma();
  float current_ma() const;
  void set_current_ma(float value);
  private:
  float _internal_current_ma() const;
  void _internal_set_current_ma(float value);
  public:

  // float current_max_ma = 4;
  bool has_current_max_ma() const;
  private:
  bool _internal_has_current_max_ma() const;
  public:
  void clear_current_max_ma();
  float current_max_ma() const;
  void set_current_max_ma(float value);
  private:
  float _internal_current_max_ma() const;
  void _internal_set_current_max_ma(float value);
  public:

  // float current_calibration_percent = 5;
  bool has_current_calibration_percent() const;
  private:
  bool _internal_has_current_calibration_percent() const;
  public:
  void clear_current_calibration_percent();
  float current_calibration_percent() const;
  void set_current_calibration_percent(float value);
  private:
  float _internal_current_calibration_percent() const;
  void _internal_set_current_calibration_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.LddSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float frequency_hz_;
  float duration_ms_;
  float current_ma_;
  float current_max_ma_;
  float current_calibration_percent_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class TecSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.TecSettings) */ {
 public:
  inline TecSettings() : TecSettings(nullptr) {}
  virtual ~TecSettings();
  explicit constexpr TecSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TecSettings(const TecSettings& from);
  TecSettings(TecSettings&& from) noexcept
    : TecSettings() {
    *this = ::std::move(from);
  }

  inline TecSettings& operator=(const TecSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TecSettings& operator=(TecSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TecSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TecSettings* internal_default_instance() {
    return reinterpret_cast<const TecSettings*>(
               &_TecSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TecSettings& a, TecSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(TecSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TecSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TecSettings* New() const final {
    return CreateMaybeMessage<TecSettings>(nullptr);
  }

  TecSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TecSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TecSettings& from);
  void MergeFrom(const TecSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TecSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.TecSettings";
  }
  protected:
  explicit TecSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureCelsiusFieldNumber = 1,
    kTempMaxCelsiusFieldNumber = 2,
    kTempMinCelsiusFieldNumber = 3,
    kCurrentLimitAFieldNumber = 4,
    kCalibrationPercentFieldNumber = 5,
    kInternalNtcBCoefficientFieldNumber = 6,
  };
  // float temperature_celsius = 1;
  bool has_temperature_celsius() const;
  private:
  bool _internal_has_temperature_celsius() const;
  public:
  void clear_temperature_celsius();
  float temperature_celsius() const;
  void set_temperature_celsius(float value);
  private:
  float _internal_temperature_celsius() const;
  void _internal_set_temperature_celsius(float value);
  public:

  // float temp_max_celsius = 2;
  bool has_temp_max_celsius() const;
  private:
  bool _internal_has_temp_max_celsius() const;
  public:
  void clear_temp_max_celsius();
  float temp_max_celsius() const;
  void set_temp_max_celsius(float value);
  private:
  float _internal_temp_max_celsius() const;
  void _internal_set_temp_max_celsius(float value);
  public:

  // float temp_min_celsius = 3;
  bool has_temp_min_celsius() const;
  private:
  bool _internal_has_temp_min_celsius() const;
  public:
  void clear_temp_min_celsius();
  float temp_min_celsius() const;
  void set_temp_min_celsius(float value);
  private:
  float _internal_temp_min_celsius() const;
  void _internal_set_temp_min_celsius(float value);
  public:

  // float current_limit_a = 4;
  bool has_current_limit_a() const;
  private:
  bool _internal_has_current_limit_a() const;
  public:
  void clear_current_limit_a();
  float current_limit_a() const;
  void set_current_limit_a(float value);
  private:
  float _internal_current_limit_a() const;
  void _internal_set_current_limit_a(float value);
  public:

  // float calibration_percent = 5;
  bool has_calibration_percent() const;
  private:
  bool _internal_has_calibration_percent() const;
  public:
  void clear_calibration_percent();
  float calibration_percent() const;
  void set_calibration_percent(float value);
  private:
  float _internal_calibration_percent() const;
  void _internal_set_calibration_percent(float value);
  public:

  // uint32 internal_ntc_b_coefficient = 6;
  bool has_internal_ntc_b_coefficient() const;
  private:
  bool _internal_has_internal_ntc_b_coefficient() const;
  public:
  void clear_internal_ntc_b_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 internal_ntc_b_coefficient() const;
  void set_internal_ntc_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_internal_ntc_b_coefficient() const;
  void _internal_set_internal_ntc_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.TecSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float temperature_celsius_;
  float temp_max_celsius_;
  float temp_min_celsius_;
  float current_limit_a_;
  float calibration_percent_;
  ::PROTOBUF_NAMESPACE_ID::uint32 internal_ntc_b_coefficient_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class PidSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.PidSettings) */ {
 public:
  inline PidSettings() : PidSettings(nullptr) {}
  virtual ~PidSettings();
  explicit constexpr PidSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PidSettings(const PidSettings& from);
  PidSettings(PidSettings&& from) noexcept
    : PidSettings() {
    *this = ::std::move(from);
  }

  inline PidSettings& operator=(const PidSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline PidSettings& operator=(PidSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PidSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const PidSettings* internal_default_instance() {
    return reinterpret_cast<const PidSettings*>(
               &_PidSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PidSettings& a, PidSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(PidSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PidSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PidSettings* New() const final {
    return CreateMaybeMessage<PidSettings>(nullptr);
  }

  PidSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PidSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PidSettings& from);
  void MergeFrom(const PidSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PidSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.PidSettings";
  }
  protected:
  explicit PidSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPCoefficientFieldNumber = 1,
    kICoefficientFieldNumber = 2,
    kDCoefficientFieldNumber = 3,
  };
  // uint32 p_coefficient = 1;
  bool has_p_coefficient() const;
  private:
  bool _internal_has_p_coefficient() const;
  public:
  void clear_p_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 p_coefficient() const;
  void set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_p_coefficient() const;
  void _internal_set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 i_coefficient = 2;
  bool has_i_coefficient() const;
  private:
  bool _internal_has_i_coefficient() const;
  public:
  void clear_i_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 i_coefficient() const;
  void set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_i_coefficient() const;
  void _internal_set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 d_coefficient = 3;
  bool has_d_coefficient() const;
  private:
  bool _internal_has_d_coefficient() const;
  public:
  void clear_d_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 d_coefficient() const;
  void set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_d_coefficient() const;
  void _internal_set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.PidSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 p_coefficient_;
  ::PROTOBUF_NAMESPACE_ID::uint32 i_coefficient_;
  ::PROTOBUF_NAMESPACE_ID::uint32 d_coefficient_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class NtcInterlockSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.NtcInterlockSettings) */ {
 public:
  inline NtcInterlockSettings() : NtcInterlockSettings(nullptr) {}
  virtual ~NtcInterlockSettings();
  explicit constexpr NtcInterlockSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NtcInterlockSettings(const NtcInterlockSettings& from);
  NtcInterlockSettings(NtcInterlockSettings&& from) noexcept
    : NtcInterlockSettings() {
    *this = ::std::move(from);
  }

  inline NtcInterlockSettings& operator=(const NtcInterlockSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline NtcInterlockSettings& operator=(NtcInterlockSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NtcInterlockSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const NtcInterlockSettings* internal_default_instance() {
    return reinterpret_cast<const NtcInterlockSettings*>(
               &_NtcInterlockSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(NtcInterlockSettings& a, NtcInterlockSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(NtcInterlockSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NtcInterlockSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NtcInterlockSettings* New() const final {
    return CreateMaybeMessage<NtcInterlockSettings>(nullptr);
  }

  NtcInterlockSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NtcInterlockSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NtcInterlockSettings& from);
  void MergeFrom(const NtcInterlockSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NtcInterlockSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.NtcInterlockSettings";
  }
  protected:
  explicit NtcInterlockSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerLimitCelsiusFieldNumber = 1,
    kUpperLimitCelsiusFieldNumber = 2,
    kBCoefficientFieldNumber = 3,
  };
  // float lower_limit_celsius = 1;
  bool has_lower_limit_celsius() const;
  private:
  bool _internal_has_lower_limit_celsius() const;
  public:
  void clear_lower_limit_celsius();
  float lower_limit_celsius() const;
  void set_lower_limit_celsius(float value);
  private:
  float _internal_lower_limit_celsius() const;
  void _internal_set_lower_limit_celsius(float value);
  public:

  // float upper_limit_celsius = 2;
  bool has_upper_limit_celsius() const;
  private:
  bool _internal_has_upper_limit_celsius() const;
  public:
  void clear_upper_limit_celsius();
  float upper_limit_celsius() const;
  void set_upper_limit_celsius(float value);
  private:
  float _internal_upper_limit_celsius() const;
  void _internal_set_upper_limit_celsius(float value);
  public:

  // uint32 b_coefficient = 3;
  bool has_b_coefficient() const;
  private:
  bool _internal_has_b_coefficient() const;
  public:
  void clear_b_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 b_coefficient() const;
  void set_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_b_coefficient() const;
  void _internal_set_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.NtcInterlockSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float lower_limit_celsius_;
  float upper_limit_celsius_;
  ::PROTOBUF_NAMESPACE_ID::uint32 b_coefficient_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class DriverStateSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.DriverStateSettings) */ {
 public:
  inline DriverStateSettings() : DriverStateSettings(nullptr) {}
  virtual ~DriverStateSettings();
  explicit constexpr DriverStateSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriverStateSettings(const DriverStateSettings& from);
  DriverStateSettings(DriverStateSettings&& from) noexcept
    : DriverStateSettings() {
    *this = ::std::move(from);
  }

  inline DriverStateSettings& operator=(const DriverStateSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriverStateSettings& operator=(DriverStateSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriverStateSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriverStateSettings* internal_default_instance() {
    return reinterpret_cast<const DriverStateSettings*>(
               &_DriverStateSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DriverStateSettings& a, DriverStateSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(DriverStateSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriverStateSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DriverStateSettings* New() const final {
    return CreateMaybeMessage<DriverStateSettings>(nullptr);
  }

  DriverStateSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DriverStateSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DriverStateSettings& from);
  void MergeFrom(const DriverStateSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriverStateSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.DriverStateSettings";
  }
  protected:
  explicit DriverStateSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DriverStateSettings_CurrentSetSource CurrentSetSource;
  static constexpr CurrentSetSource CURRENT_SET_SOURCE_UNSPECIFIED =
    DriverStateSettings_CurrentSetSource_CURRENT_SET_SOURCE_UNSPECIFIED;
  static constexpr CurrentSetSource EXTERNAL =
    DriverStateSettings_CurrentSetSource_EXTERNAL;
  static constexpr CurrentSetSource INTERNAL =
    DriverStateSettings_CurrentSetSource_INTERNAL;
  static inline bool CurrentSetSource_IsValid(int value) {
    return DriverStateSettings_CurrentSetSource_IsValid(value);
  }
  static constexpr CurrentSetSource CurrentSetSource_MIN =
    DriverStateSettings_CurrentSetSource_CurrentSetSource_MIN;
  static constexpr CurrentSetSource CurrentSetSource_MAX =
    DriverStateSettings_CurrentSetSource_CurrentSetSource_MAX;
  static constexpr int CurrentSetSource_ARRAYSIZE =
    DriverStateSettings_CurrentSetSource_CurrentSetSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& CurrentSetSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CurrentSetSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CurrentSetSource_Name.");
    return DriverStateSettings_CurrentSetSource_Name(enum_t_value);
  }
  static inline bool CurrentSetSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CurrentSetSource* value) {
    return DriverStateSettings_CurrentSetSource_Parse(name, value);
  }

  typedef DriverStateSettings_EnableSource EnableSource;
  static constexpr EnableSource ENABLE_SOURCE_UNSPECIFIED =
    DriverStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED;
  static constexpr EnableSource EXTERNAL_PIN =
    DriverStateSettings_EnableSource_EXTERNAL_PIN;
  static constexpr EnableSource INTERNAL_CMD =
    DriverStateSettings_EnableSource_INTERNAL_CMD;
  static inline bool EnableSource_IsValid(int value) {
    return DriverStateSettings_EnableSource_IsValid(value);
  }
  static constexpr EnableSource EnableSource_MIN =
    DriverStateSettings_EnableSource_EnableSource_MIN;
  static constexpr EnableSource EnableSource_MAX =
    DriverStateSettings_EnableSource_EnableSource_MAX;
  static constexpr int EnableSource_ARRAYSIZE =
    DriverStateSettings_EnableSource_EnableSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EnableSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnableSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnableSource_Name.");
    return DriverStateSettings_EnableSource_Name(enum_t_value);
  }
  static inline bool EnableSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnableSource* value) {
    return DriverStateSettings_EnableSource_Parse(name, value);
  }

  typedef DriverStateSettings_InterlockPolicy InterlockPolicy;
  static constexpr InterlockPolicy INTERLOCK_POLICY_UNSPECIFIED =
    DriverStateSettings_InterlockPolicy_INTERLOCK_POLICY_UNSPECIFIED;
  static constexpr InterlockPolicy ALLOW =
    DriverStateSettings_InterlockPolicy_ALLOW;
  static constexpr InterlockPolicy DENY =
    DriverStateSettings_InterlockPolicy_DENY;
  static inline bool InterlockPolicy_IsValid(int value) {
    return DriverStateSettings_InterlockPolicy_IsValid(value);
  }
  static constexpr InterlockPolicy InterlockPolicy_MIN =
    DriverStateSettings_InterlockPolicy_InterlockPolicy_MIN;
  static constexpr InterlockPolicy InterlockPolicy_MAX =
    DriverStateSettings_InterlockPolicy_InterlockPolicy_MAX;
  static constexpr int InterlockPolicy_ARRAYSIZE =
    DriverStateSettings_InterlockPolicy_InterlockPolicy_ARRAYSIZE;
  template<typename T>
  static inline const std::string& InterlockPolicy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InterlockPolicy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InterlockPolicy_Name.");
    return DriverStateSettings_InterlockPolicy_Name(enum_t_value);
  }
  static inline bool InterlockPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InterlockPolicy* value) {
    return DriverStateSettings_InterlockPolicy_Parse(name, value);
  }

  typedef DriverStateSettings_NtcInterlockPolicy NtcInterlockPolicy;
  static constexpr NtcInterlockPolicy NTC_INTERLOCK_POLICY_UNSPECIFIED =
    DriverStateSettings_NtcInterlockPolicy_NTC_INTERLOCK_POLICY_UNSPECIFIED;
  static constexpr NtcInterlockPolicy ALLOW_NTC =
    DriverStateSettings_NtcInterlockPolicy_ALLOW_NTC;
  static constexpr NtcInterlockPolicy DENY_NTC =
    DriverStateSettings_NtcInterlockPolicy_DENY_NTC;
  static inline bool NtcInterlockPolicy_IsValid(int value) {
    return DriverStateSettings_NtcInterlockPolicy_IsValid(value);
  }
  static constexpr NtcInterlockPolicy NtcInterlockPolicy_MIN =
    DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_MIN;
  static constexpr NtcInterlockPolicy NtcInterlockPolicy_MAX =
    DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_MAX;
  static constexpr int NtcInterlockPolicy_ARRAYSIZE =
    DriverStateSettings_NtcInterlockPolicy_NtcInterlockPolicy_ARRAYSIZE;
  template<typename T>
  static inline const std::string& NtcInterlockPolicy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NtcInterlockPolicy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NtcInterlockPolicy_Name.");
    return DriverStateSettings_NtcInterlockPolicy_Name(enum_t_value);
  }
  static inline bool NtcInterlockPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NtcInterlockPolicy* value) {
    return DriverStateSettings_NtcInterlockPolicy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentSetSourceFieldNumber = 1,
    kEnableSourceFieldNumber = 2,
    kInterlockPolicyFieldNumber = 3,
    kNtcInterlockPolicyFieldNumber = 4,
  };
  // .sf8xxx_nm.DriverStateSettings.CurrentSetSource current_set_source = 1;
  bool has_current_set_source() const;
  private:
  bool _internal_has_current_set_source() const;
  public:
  void clear_current_set_source();
  ::sf8xxx_nm::DriverStateSettings_CurrentSetSource current_set_source() const;
  void set_current_set_source(::sf8xxx_nm::DriverStateSettings_CurrentSetSource value);
  private:
  ::sf8xxx_nm::DriverStateSettings_CurrentSetSource _internal_current_set_source() const;
  void _internal_set_current_set_source(::sf8xxx_nm::DriverStateSettings_CurrentSetSource value);
  public:

  // .sf8xxx_nm.DriverStateSettings.EnableSource enable_source = 2;
  bool has_enable_source() const;
  private:
  bool _internal_has_enable_source() const;
  public:
  void clear_enable_source();
  ::sf8xxx_nm::DriverStateSettings_EnableSource enable_source() const;
  void set_enable_source(::sf8xxx_nm::DriverStateSettings_EnableSource value);
  private:
  ::sf8xxx_nm::DriverStateSettings_EnableSource _internal_enable_source() const;
  void _internal_set_enable_source(::sf8xxx_nm::DriverStateSettings_EnableSource value);
  public:

  // .sf8xxx_nm.DriverStateSettings.InterlockPolicy interlock_policy = 3;
  bool has_interlock_policy() const;
  private:
  bool _internal_has_interlock_policy() const;
  public:
  void clear_interlock_policy();
  ::sf8xxx_nm::DriverStateSettings_InterlockPolicy interlock_policy() const;
  void set_interlock_policy(::sf8xxx_nm::DriverStateSettings_InterlockPolicy value);
  private:
  ::sf8xxx_nm::DriverStateSettings_InterlockPolicy _internal_interlock_policy() const;
  void _internal_set_interlock_policy(::sf8xxx_nm::DriverStateSettings_InterlockPolicy value);
  public:

  // .sf8xxx_nm.DriverStateSettings.NtcInterlockPolicy ntc_interlock_policy = 4;
  bool has_ntc_interlock_policy() const;
  private:
  bool _internal_has_ntc_interlock_policy() const;
  public:
  void clear_ntc_interlock_policy();
  ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy ntc_interlock_policy() const;
  void set_ntc_interlock_policy(::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy value);
  private:
  ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy _internal_ntc_interlock_policy() const;
  void _internal_set_ntc_interlock_policy(::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.DriverStateSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int current_set_source_;
  int enable_source_;
  int interlock_policy_;
  int ntc_interlock_policy_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class TecStateSettings PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.TecStateSettings) */ {
 public:
  inline TecStateSettings() : TecStateSettings(nullptr) {}
  virtual ~TecStateSettings();
  explicit constexpr TecStateSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TecStateSettings(const TecStateSettings& from);
  TecStateSettings(TecStateSettings&& from) noexcept
    : TecStateSettings() {
    *this = ::std::move(from);
  }

  inline TecStateSettings& operator=(const TecStateSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TecStateSettings& operator=(TecStateSettings&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TecStateSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TecStateSettings* internal_default_instance() {
    return reinterpret_cast<const TecStateSettings*>(
               &_TecStateSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TecStateSettings& a, TecStateSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(TecStateSettings* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TecStateSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TecStateSettings* New() const final {
    return CreateMaybeMessage<TecStateSettings>(nullptr);
  }

  TecStateSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TecStateSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TecStateSettings& from);
  void MergeFrom(const TecStateSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TecStateSettings* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.TecStateSettings";
  }
  protected:
  explicit TecStateSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TecStateSettings_TempSetSource TempSetSource;
  static constexpr TempSetSource TEMP_SET_SOURCE_UNSPECIFIED =
    TecStateSettings_TempSetSource_TEMP_SET_SOURCE_UNSPECIFIED;
  static constexpr TempSetSource EXTERNAL =
    TecStateSettings_TempSetSource_EXTERNAL;
  static constexpr TempSetSource INTERNAL =
    TecStateSettings_TempSetSource_INTERNAL;
  static inline bool TempSetSource_IsValid(int value) {
    return TecStateSettings_TempSetSource_IsValid(value);
  }
  static constexpr TempSetSource TempSetSource_MIN =
    TecStateSettings_TempSetSource_TempSetSource_MIN;
  static constexpr TempSetSource TempSetSource_MAX =
    TecStateSettings_TempSetSource_TempSetSource_MAX;
  static constexpr int TempSetSource_ARRAYSIZE =
    TecStateSettings_TempSetSource_TempSetSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& TempSetSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TempSetSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TempSetSource_Name.");
    return TecStateSettings_TempSetSource_Name(enum_t_value);
  }
  static inline bool TempSetSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TempSetSource* value) {
    return TecStateSettings_TempSetSource_Parse(name, value);
  }

  typedef TecStateSettings_EnableSource EnableSource;
  static constexpr EnableSource ENABLE_SOURCE_UNSPECIFIED =
    TecStateSettings_EnableSource_ENABLE_SOURCE_UNSPECIFIED;
  static constexpr EnableSource EXTERNAL_PIN =
    TecStateSettings_EnableSource_EXTERNAL_PIN;
  static constexpr EnableSource INTERNAL_CMD =
    TecStateSettings_EnableSource_INTERNAL_CMD;
  static inline bool EnableSource_IsValid(int value) {
    return TecStateSettings_EnableSource_IsValid(value);
  }
  static constexpr EnableSource EnableSource_MIN =
    TecStateSettings_EnableSource_EnableSource_MIN;
  static constexpr EnableSource EnableSource_MAX =
    TecStateSettings_EnableSource_EnableSource_MAX;
  static constexpr int EnableSource_ARRAYSIZE =
    TecStateSettings_EnableSource_EnableSource_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EnableSource_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnableSource>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnableSource_Name.");
    return TecStateSettings_EnableSource_Name(enum_t_value);
  }
  static inline bool EnableSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnableSource* value) {
    return TecStateSettings_EnableSource_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTempSetSourceFieldNumber = 1,
    kEnableSourceFieldNumber = 2,
  };
  // .sf8xxx_nm.TecStateSettings.TempSetSource temp_set_source = 1;
  bool has_temp_set_source() const;
  private:
  bool _internal_has_temp_set_source() const;
  public:
  void clear_temp_set_source();
  ::sf8xxx_nm::TecStateSettings_TempSetSource temp_set_source() const;
  void set_temp_set_source(::sf8xxx_nm::TecStateSettings_TempSetSource value);
  private:
  ::sf8xxx_nm::TecStateSettings_TempSetSource _internal_temp_set_source() const;
  void _internal_set_temp_set_source(::sf8xxx_nm::TecStateSettings_TempSetSource value);
  public:

  // .sf8xxx_nm.TecStateSettings.EnableSource enable_source = 2;
  bool has_enable_source() const;
  private:
  bool _internal_has_enable_source() const;
  public:
  void clear_enable_source();
  ::sf8xxx_nm::TecStateSettings_EnableSource enable_source() const;
  void set_enable_source(::sf8xxx_nm::TecStateSettings_EnableSource value);
  private:
  ::sf8xxx_nm::TecStateSettings_EnableSource _internal_enable_source() const;
  void _internal_set_enable_source(::sf8xxx_nm::TecStateSettings_EnableSource value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.TecStateSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int temp_set_source_;
  int enable_source_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class RequestCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.RequestCommand) */ {
 public:
  inline RequestCommand() : RequestCommand(nullptr) {}
  virtual ~RequestCommand();
  explicit constexpr RequestCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestCommand(const RequestCommand& from);
  RequestCommand(RequestCommand&& from) noexcept
    : RequestCommand() {
    *this = ::std::move(from);
  }

  inline RequestCommand& operator=(const RequestCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestCommand& operator=(RequestCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RequestCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestCommand* internal_default_instance() {
    return reinterpret_cast<const RequestCommand*>(
               &_RequestCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RequestCommand& a, RequestCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RequestCommand* New() const final {
    return CreateMaybeMessage<RequestCommand>(nullptr);
  }

  RequestCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RequestCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RequestCommand& from);
  void MergeFrom(const RequestCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RequestCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.RequestCommand";
  }
  protected:
  explicit RequestCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .sf8xxx_nm.RequestType requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  private:
  ::sf8xxx_nm::RequestType _internal_requests(int index) const;
  void _internal_add_requests(::sf8xxx_nm::RequestType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_requests();
  public:
  ::sf8xxx_nm::RequestType requests(int index) const;
  void set_requests(int index, ::sf8xxx_nm::RequestType value);
  void add_requests(::sf8xxx_nm::RequestType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& requests() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_requests();

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.RequestCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> requests_;
  mutable std::atomic<int> _requests_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class ActionCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.ActionCommand) */ {
 public:
  inline ActionCommand() : ActionCommand(nullptr) {}
  virtual ~ActionCommand();
  explicit constexpr ActionCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionCommand(const ActionCommand& from);
  ActionCommand(ActionCommand&& from) noexcept
    : ActionCommand() {
    *this = ::std::move(from);
  }

  inline ActionCommand& operator=(const ActionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionCommand& operator=(ActionCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ActionCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionCommand* internal_default_instance() {
    return reinterpret_cast<const ActionCommand*>(
               &_ActionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ActionCommand& a, ActionCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionCommand* New() const final {
    return CreateMaybeMessage<ActionCommand>(nullptr);
  }

  ActionCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionCommand>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ActionCommand& from);
  void MergeFrom(const ActionCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActionCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.ActionCommand";
  }
  protected:
  explicit ActionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .sf8xxx_nm.ActionType type = 1;
  void clear_type();
  ::sf8xxx_nm::ActionType type() const;
  void set_type(::sf8xxx_nm::ActionType value);
  private:
  ::sf8xxx_nm::ActionType _internal_type() const;
  void _internal_set_type(::sf8xxx_nm::ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.ActionCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class LddStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.LddStatus) */ {
 public:
  inline LddStatus() : LddStatus(nullptr) {}
  virtual ~LddStatus();
  explicit constexpr LddStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LddStatus(const LddStatus& from);
  LddStatus(LddStatus&& from) noexcept
    : LddStatus() {
    *this = ::std::move(from);
  }

  inline LddStatus& operator=(const LddStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline LddStatus& operator=(LddStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LddStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const LddStatus* internal_default_instance() {
    return reinterpret_cast<const LddStatus*>(
               &_LddStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LddStatus& a, LddStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(LddStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LddStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LddStatus* New() const final {
    return CreateMaybeMessage<LddStatus>(nullptr);
  }

  LddStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LddStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LddStatus& from);
  void MergeFrom(const LddStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LddStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.LddStatus";
  }
  protected:
  explicit LddStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrequencyHzFieldNumber = 1,
    kFrequencyMinHzFieldNumber = 2,
    kFrequencyMaxHzFieldNumber = 3,
    kDurationMsFieldNumber = 4,
    kDurationMinMsFieldNumber = 5,
    kDurationMaxMsFieldNumber = 6,
    kCurrentMaFieldNumber = 7,
    kCurrentMinMaFieldNumber = 8,
    kCurrentMaxMaFieldNumber = 9,
    kCurrentMaxLimitMaFieldNumber = 10,
    kMeasuredCurrentMaFieldNumber = 11,
    kCurrentProtectionThresholdMaFieldNumber = 12,
    kCurrentCalibrationPercentFieldNumber = 13,
    kMeasuredVoltageVFieldNumber = 14,
  };
  // float frequency_hz = 1;
  void clear_frequency_hz();
  float frequency_hz() const;
  void set_frequency_hz(float value);
  private:
  float _internal_frequency_hz() const;
  void _internal_set_frequency_hz(float value);
  public:

  // float frequency_min_hz = 2;
  void clear_frequency_min_hz();
  float frequency_min_hz() const;
  void set_frequency_min_hz(float value);
  private:
  float _internal_frequency_min_hz() const;
  void _internal_set_frequency_min_hz(float value);
  public:

  // float frequency_max_hz = 3;
  void clear_frequency_max_hz();
  float frequency_max_hz() const;
  void set_frequency_max_hz(float value);
  private:
  float _internal_frequency_max_hz() const;
  void _internal_set_frequency_max_hz(float value);
  public:

  // float duration_ms = 4;
  void clear_duration_ms();
  float duration_ms() const;
  void set_duration_ms(float value);
  private:
  float _internal_duration_ms() const;
  void _internal_set_duration_ms(float value);
  public:

  // float duration_min_ms = 5;
  void clear_duration_min_ms();
  float duration_min_ms() const;
  void set_duration_min_ms(float value);
  private:
  float _internal_duration_min_ms() const;
  void _internal_set_duration_min_ms(float value);
  public:

  // float duration_max_ms = 6;
  void clear_duration_max_ms();
  float duration_max_ms() const;
  void set_duration_max_ms(float value);
  private:
  float _internal_duration_max_ms() const;
  void _internal_set_duration_max_ms(float value);
  public:

  // float current_ma = 7;
  void clear_current_ma();
  float current_ma() const;
  void set_current_ma(float value);
  private:
  float _internal_current_ma() const;
  void _internal_set_current_ma(float value);
  public:

  // float current_min_ma = 8;
  void clear_current_min_ma();
  float current_min_ma() const;
  void set_current_min_ma(float value);
  private:
  float _internal_current_min_ma() const;
  void _internal_set_current_min_ma(float value);
  public:

  // float current_max_ma = 9;
  void clear_current_max_ma();
  float current_max_ma() const;
  void set_current_max_ma(float value);
  private:
  float _internal_current_max_ma() const;
  void _internal_set_current_max_ma(float value);
  public:

  // float current_max_limit_ma = 10;
  void clear_current_max_limit_ma();
  float current_max_limit_ma() const;
  void set_current_max_limit_ma(float value);
  private:
  float _internal_current_max_limit_ma() const;
  void _internal_set_current_max_limit_ma(float value);
  public:

  // float measured_current_ma = 11;
  void clear_measured_current_ma();
  float measured_current_ma() const;
  void set_measured_current_ma(float value);
  private:
  float _internal_measured_current_ma() const;
  void _internal_set_measured_current_ma(float value);
  public:

  // float current_protection_threshold_ma = 12;
  void clear_current_protection_threshold_ma();
  float current_protection_threshold_ma() const;
  void set_current_protection_threshold_ma(float value);
  private:
  float _internal_current_protection_threshold_ma() const;
  void _internal_set_current_protection_threshold_ma(float value);
  public:

  // float current_calibration_percent = 13;
  void clear_current_calibration_percent();
  float current_calibration_percent() const;
  void set_current_calibration_percent(float value);
  private:
  float _internal_current_calibration_percent() const;
  void _internal_set_current_calibration_percent(float value);
  public:

  // float measured_voltage_v = 14;
  void clear_measured_voltage_v();
  float measured_voltage_v() const;
  void set_measured_voltage_v(float value);
  private:
  float _internal_measured_voltage_v() const;
  void _internal_set_measured_voltage_v(float value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.LddStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float frequency_hz_;
  float frequency_min_hz_;
  float frequency_max_hz_;
  float duration_ms_;
  float duration_min_ms_;
  float duration_max_ms_;
  float current_ma_;
  float current_min_ma_;
  float current_max_ma_;
  float current_max_limit_ma_;
  float measured_current_ma_;
  float current_protection_threshold_ma_;
  float current_calibration_percent_;
  float measured_voltage_v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class TecStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.TecStatus) */ {
 public:
  inline TecStatus() : TecStatus(nullptr) {}
  virtual ~TecStatus();
  explicit constexpr TecStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TecStatus(const TecStatus& from);
  TecStatus(TecStatus&& from) noexcept
    : TecStatus() {
    *this = ::std::move(from);
  }

  inline TecStatus& operator=(const TecStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline TecStatus& operator=(TecStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TecStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const TecStatus* internal_default_instance() {
    return reinterpret_cast<const TecStatus*>(
               &_TecStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TecStatus& a, TecStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(TecStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TecStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TecStatus* New() const final {
    return CreateMaybeMessage<TecStatus>(nullptr);
  }

  TecStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TecStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TecStatus& from);
  void MergeFrom(const TecStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TecStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.TecStatus";
  }
  protected:
  explicit TecStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureCelsiusFieldNumber = 1,
    kTempMaxCelsiusFieldNumber = 2,
    kTempMinCelsiusFieldNumber = 3,
    kTempMaxLimitCelsiusFieldNumber = 4,
    kTempMinLimitCelsiusFieldNumber = 5,
    kMeasuredTemperatureCelsiusFieldNumber = 6,
    kMeasuredCurrentAFieldNumber = 7,
    kCurrentLimitAFieldNumber = 8,
    kMeasuredVoltageVFieldNumber = 9,
    kCalibrationPercentFieldNumber = 10,
    kPCoefficientFieldNumber = 11,
    kICoefficientFieldNumber = 12,
    kDCoefficientFieldNumber = 13,
    kExternalNtcLowerLimitCelsiusFieldNumber = 14,
    kExternalNtcUpperLimitCelsiusFieldNumber = 15,
    kExternalNtcMeasuredTempCelsiusFieldNumber = 16,
  };
  // float temperature_celsius = 1;
  void clear_temperature_celsius();
  float temperature_celsius() const;
  void set_temperature_celsius(float value);
  private:
  float _internal_temperature_celsius() const;
  void _internal_set_temperature_celsius(float value);
  public:

  // float temp_max_celsius = 2;
  void clear_temp_max_celsius();
  float temp_max_celsius() const;
  void set_temp_max_celsius(float value);
  private:
  float _internal_temp_max_celsius() const;
  void _internal_set_temp_max_celsius(float value);
  public:

  // float temp_min_celsius = 3;
  void clear_temp_min_celsius();
  float temp_min_celsius() const;
  void set_temp_min_celsius(float value);
  private:
  float _internal_temp_min_celsius() const;
  void _internal_set_temp_min_celsius(float value);
  public:

  // float temp_max_limit_celsius = 4;
  void clear_temp_max_limit_celsius();
  float temp_max_limit_celsius() const;
  void set_temp_max_limit_celsius(float value);
  private:
  float _internal_temp_max_limit_celsius() const;
  void _internal_set_temp_max_limit_celsius(float value);
  public:

  // float temp_min_limit_celsius = 5;
  void clear_temp_min_limit_celsius();
  float temp_min_limit_celsius() const;
  void set_temp_min_limit_celsius(float value);
  private:
  float _internal_temp_min_limit_celsius() const;
  void _internal_set_temp_min_limit_celsius(float value);
  public:

  // float measured_temperature_celsius = 6;
  void clear_measured_temperature_celsius();
  float measured_temperature_celsius() const;
  void set_measured_temperature_celsius(float value);
  private:
  float _internal_measured_temperature_celsius() const;
  void _internal_set_measured_temperature_celsius(float value);
  public:

  // float measured_current_a = 7;
  void clear_measured_current_a();
  float measured_current_a() const;
  void set_measured_current_a(float value);
  private:
  float _internal_measured_current_a() const;
  void _internal_set_measured_current_a(float value);
  public:

  // float current_limit_a = 8;
  void clear_current_limit_a();
  float current_limit_a() const;
  void set_current_limit_a(float value);
  private:
  float _internal_current_limit_a() const;
  void _internal_set_current_limit_a(float value);
  public:

  // float measured_voltage_v = 9;
  void clear_measured_voltage_v();
  float measured_voltage_v() const;
  void set_measured_voltage_v(float value);
  private:
  float _internal_measured_voltage_v() const;
  void _internal_set_measured_voltage_v(float value);
  public:

  // float calibration_percent = 10;
  void clear_calibration_percent();
  float calibration_percent() const;
  void set_calibration_percent(float value);
  private:
  float _internal_calibration_percent() const;
  void _internal_set_calibration_percent(float value);
  public:

  // uint32 p_coefficient = 11;
  void clear_p_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 p_coefficient() const;
  void set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_p_coefficient() const;
  void _internal_set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 i_coefficient = 12;
  void clear_i_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 i_coefficient() const;
  void set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_i_coefficient() const;
  void _internal_set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 d_coefficient = 13;
  void clear_d_coefficient();
  ::PROTOBUF_NAMESPACE_ID::uint32 d_coefficient() const;
  void set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_d_coefficient() const;
  void _internal_set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float external_ntc_lower_limit_celsius = 14;
  void clear_external_ntc_lower_limit_celsius();
  float external_ntc_lower_limit_celsius() const;
  void set_external_ntc_lower_limit_celsius(float value);
  private:
  float _internal_external_ntc_lower_limit_celsius() const;
  void _internal_set_external_ntc_lower_limit_celsius(float value);
  public:

  // float external_ntc_upper_limit_celsius = 15;
  void clear_external_ntc_upper_limit_celsius();
  float external_ntc_upper_limit_celsius() const;
  void set_external_ntc_upper_limit_celsius(float value);
  private:
  float _internal_external_ntc_upper_limit_celsius() const;
  void _internal_set_external_ntc_upper_limit_celsius(float value);
  public:

  // float external_ntc_measured_temp_celsius = 16;
  void clear_external_ntc_measured_temp_celsius();
  float external_ntc_measured_temp_celsius() const;
  void set_external_ntc_measured_temp_celsius(float value);
  private:
  float _internal_external_ntc_measured_temp_celsius() const;
  void _internal_set_external_ntc_measured_temp_celsius(float value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.TecStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float temperature_celsius_;
  float temp_max_celsius_;
  float temp_min_celsius_;
  float temp_max_limit_celsius_;
  float temp_min_limit_celsius_;
  float measured_temperature_celsius_;
  float measured_current_a_;
  float current_limit_a_;
  float measured_voltage_v_;
  float calibration_percent_;
  ::PROTOBUF_NAMESPACE_ID::uint32 p_coefficient_;
  ::PROTOBUF_NAMESPACE_ID::uint32 i_coefficient_;
  ::PROTOBUF_NAMESPACE_ID::uint32 d_coefficient_;
  float external_ntc_lower_limit_celsius_;
  float external_ntc_upper_limit_celsius_;
  float external_ntc_measured_temp_celsius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class DriverStateInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.DriverStateInfo) */ {
 public:
  inline DriverStateInfo() : DriverStateInfo(nullptr) {}
  virtual ~DriverStateInfo();
  explicit constexpr DriverStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DriverStateInfo(const DriverStateInfo& from);
  DriverStateInfo(DriverStateInfo&& from) noexcept
    : DriverStateInfo() {
    *this = ::std::move(from);
  }

  inline DriverStateInfo& operator=(const DriverStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DriverStateInfo& operator=(DriverStateInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DriverStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DriverStateInfo* internal_default_instance() {
    return reinterpret_cast<const DriverStateInfo*>(
               &_DriverStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DriverStateInfo& a, DriverStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DriverStateInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DriverStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DriverStateInfo* New() const final {
    return CreateMaybeMessage<DriverStateInfo>(nullptr);
  }

  DriverStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DriverStateInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const DriverStateInfo& from);
  void MergeFrom(const DriverStateInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DriverStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.DriverStateInfo";
  }
  protected:
  explicit DriverStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsPoweredOnFieldNumber = 1,
    kIsStartedFieldNumber = 2,
    kCurrentSetIsInternalFieldNumber = 3,
    kEnableIsInternalFieldNumber = 4,
    kExtNtcInterlockIsDeniedFieldNumber = 5,
    kInterlockIsDeniedFieldNumber = 6,
  };
  // bool is_powered_on = 1;
  void clear_is_powered_on();
  bool is_powered_on() const;
  void set_is_powered_on(bool value);
  private:
  bool _internal_is_powered_on() const;
  void _internal_set_is_powered_on(bool value);
  public:

  // bool is_started = 2;
  void clear_is_started();
  bool is_started() const;
  void set_is_started(bool value);
  private:
  bool _internal_is_started() const;
  void _internal_set_is_started(bool value);
  public:

  // bool current_set_is_internal = 3;
  void clear_current_set_is_internal();
  bool current_set_is_internal() const;
  void set_current_set_is_internal(bool value);
  private:
  bool _internal_current_set_is_internal() const;
  void _internal_set_current_set_is_internal(bool value);
  public:

  // bool enable_is_internal = 4;
  void clear_enable_is_internal();
  bool enable_is_internal() const;
  void set_enable_is_internal(bool value);
  private:
  bool _internal_enable_is_internal() const;
  void _internal_set_enable_is_internal(bool value);
  public:

  // bool ext_ntc_interlock_is_denied = 5;
  void clear_ext_ntc_interlock_is_denied();
  bool ext_ntc_interlock_is_denied() const;
  void set_ext_ntc_interlock_is_denied(bool value);
  private:
  bool _internal_ext_ntc_interlock_is_denied() const;
  void _internal_set_ext_ntc_interlock_is_denied(bool value);
  public:

  // bool interlock_is_denied = 6;
  void clear_interlock_is_denied();
  bool interlock_is_denied() const;
  void set_interlock_is_denied(bool value);
  private:
  bool _internal_interlock_is_denied() const;
  void _internal_set_interlock_is_denied(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.DriverStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_powered_on_;
  bool is_started_;
  bool current_set_is_internal_;
  bool enable_is_internal_;
  bool ext_ntc_interlock_is_denied_;
  bool interlock_is_denied_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class TecStateInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.TecStateInfo) */ {
 public:
  inline TecStateInfo() : TecStateInfo(nullptr) {}
  virtual ~TecStateInfo();
  explicit constexpr TecStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TecStateInfo(const TecStateInfo& from);
  TecStateInfo(TecStateInfo&& from) noexcept
    : TecStateInfo() {
    *this = ::std::move(from);
  }

  inline TecStateInfo& operator=(const TecStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TecStateInfo& operator=(TecStateInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TecStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TecStateInfo* internal_default_instance() {
    return reinterpret_cast<const TecStateInfo*>(
               &_TecStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TecStateInfo& a, TecStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TecStateInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TecStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TecStateInfo* New() const final {
    return CreateMaybeMessage<TecStateInfo>(nullptr);
  }

  TecStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TecStateInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TecStateInfo& from);
  void MergeFrom(const TecStateInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TecStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.TecStateInfo";
  }
  protected:
  explicit TecStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsStartedFieldNumber = 1,
    kTempSetIsInternalFieldNumber = 2,
    kEnableIsInternalFieldNumber = 3,
  };
  // bool is_started = 1;
  void clear_is_started();
  bool is_started() const;
  void set_is_started(bool value);
  private:
  bool _internal_is_started() const;
  void _internal_set_is_started(bool value);
  public:

  // bool temp_set_is_internal = 2;
  void clear_temp_set_is_internal();
  bool temp_set_is_internal() const;
  void set_temp_set_is_internal(bool value);
  private:
  bool _internal_temp_set_is_internal() const;
  void _internal_set_temp_set_is_internal(bool value);
  public:

  // bool enable_is_internal = 3;
  void clear_enable_is_internal();
  bool enable_is_internal() const;
  void set_enable_is_internal(bool value);
  private:
  bool _internal_enable_is_internal() const;
  void _internal_set_enable_is_internal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.TecStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_started_;
  bool temp_set_is_internal_;
  bool enable_is_internal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// -------------------------------------------------------------------

class LockStatusInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sf8xxx_nm.LockStatusInfo) */ {
 public:
  inline LockStatusInfo() : LockStatusInfo(nullptr) {}
  virtual ~LockStatusInfo();
  explicit constexpr LockStatusInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockStatusInfo(const LockStatusInfo& from);
  LockStatusInfo(LockStatusInfo&& from) noexcept
    : LockStatusInfo() {
    *this = ::std::move(from);
  }

  inline LockStatusInfo& operator=(const LockStatusInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockStatusInfo& operator=(LockStatusInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LockStatusInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockStatusInfo* internal_default_instance() {
    return reinterpret_cast<const LockStatusInfo*>(
               &_LockStatusInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LockStatusInfo& a, LockStatusInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LockStatusInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockStatusInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockStatusInfo* New() const final {
    return CreateMaybeMessage<LockStatusInfo>(nullptr);
  }

  LockStatusInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockStatusInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LockStatusInfo& from);
  void MergeFrom(const LockStatusInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LockStatusInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sf8xxx_nm.LockStatusInfo";
  }
  protected:
  explicit LockStatusInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterlockActiveFieldNumber = 1,
    kLdOverCurrentFieldNumber = 2,
    kLdOverheatFieldNumber = 3,
    kExtNtcInterlockActiveFieldNumber = 4,
    kTecErrorFieldNumber = 5,
    kTecSelfHeatFieldNumber = 6,
  };
  // bool interlock_active = 1;
  void clear_interlock_active();
  bool interlock_active() const;
  void set_interlock_active(bool value);
  private:
  bool _internal_interlock_active() const;
  void _internal_set_interlock_active(bool value);
  public:

  // bool ld_over_current = 2;
  void clear_ld_over_current();
  bool ld_over_current() const;
  void set_ld_over_current(bool value);
  private:
  bool _internal_ld_over_current() const;
  void _internal_set_ld_over_current(bool value);
  public:

  // bool ld_overheat = 3;
  void clear_ld_overheat();
  bool ld_overheat() const;
  void set_ld_overheat(bool value);
  private:
  bool _internal_ld_overheat() const;
  void _internal_set_ld_overheat(bool value);
  public:

  // bool ext_ntc_interlock_active = 4;
  void clear_ext_ntc_interlock_active();
  bool ext_ntc_interlock_active() const;
  void set_ext_ntc_interlock_active(bool value);
  private:
  bool _internal_ext_ntc_interlock_active() const;
  void _internal_set_ext_ntc_interlock_active(bool value);
  public:

  // bool tec_error = 5;
  void clear_tec_error();
  bool tec_error() const;
  void set_tec_error(bool value);
  private:
  bool _internal_tec_error() const;
  void _internal_set_tec_error(bool value);
  public:

  // bool tec_self_heat = 6;
  void clear_tec_self_heat();
  bool tec_self_heat() const;
  void set_tec_self_heat(bool value);
  private:
  bool _internal_tec_self_heat() const;
  void _internal_set_tec_self_heat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sf8xxx_nm.LockStatusInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool interlock_active_;
  bool ld_over_current_;
  bool ld_overheat_;
  bool ext_ntc_interlock_active_;
  bool tec_error_;
  bool tec_self_heat_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sf8xxx_5fnm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DriverCommand

// .sf8xxx_nm.ConfigureCommand configure = 1;
inline bool DriverCommand::_internal_has_configure() const {
  return command_case() == kConfigure;
}
inline bool DriverCommand::has_configure() const {
  return _internal_has_configure();
}
inline void DriverCommand::set_has_configure() {
  _oneof_case_[0] = kConfigure;
}
inline void DriverCommand::clear_configure() {
  if (_internal_has_configure()) {
    if (GetArena() == nullptr) {
      delete command_.configure_;
    }
    clear_has_command();
  }
}
inline ::sf8xxx_nm::ConfigureCommand* DriverCommand::release_configure() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverCommand.configure)
  if (_internal_has_configure()) {
    clear_has_command();
      ::sf8xxx_nm::ConfigureCommand* temp = command_.configure_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.configure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sf8xxx_nm::ConfigureCommand& DriverCommand::_internal_configure() const {
  return _internal_has_configure()
      ? *command_.configure_
      : reinterpret_cast< ::sf8xxx_nm::ConfigureCommand&>(::sf8xxx_nm::_ConfigureCommand_default_instance_);
}
inline const ::sf8xxx_nm::ConfigureCommand& DriverCommand::configure() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverCommand.configure)
  return _internal_configure();
}
inline ::sf8xxx_nm::ConfigureCommand* DriverCommand::unsafe_arena_release_configure() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sf8xxx_nm.DriverCommand.configure)
  if (_internal_has_configure()) {
    clear_has_command();
    ::sf8xxx_nm::ConfigureCommand* temp = command_.configure_;
    command_.configure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DriverCommand::unsafe_arena_set_allocated_configure(::sf8xxx_nm::ConfigureCommand* configure) {
  clear_command();
  if (configure) {
    set_has_configure();
    command_.configure_ = configure;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverCommand.configure)
}
inline ::sf8xxx_nm::ConfigureCommand* DriverCommand::_internal_mutable_configure() {
  if (!_internal_has_configure()) {
    clear_command();
    set_has_configure();
    command_.configure_ = CreateMaybeMessage< ::sf8xxx_nm::ConfigureCommand >(GetArena());
  }
  return command_.configure_;
}
inline ::sf8xxx_nm::ConfigureCommand* DriverCommand::mutable_configure() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverCommand.configure)
  return _internal_mutable_configure();
}

// .sf8xxx_nm.RequestCommand request = 2;
inline bool DriverCommand::_internal_has_request() const {
  return command_case() == kRequest;
}
inline bool DriverCommand::has_request() const {
  return _internal_has_request();
}
inline void DriverCommand::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void DriverCommand::clear_request() {
  if (_internal_has_request()) {
    if (GetArena() == nullptr) {
      delete command_.request_;
    }
    clear_has_command();
  }
}
inline ::sf8xxx_nm::RequestCommand* DriverCommand::release_request() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverCommand.request)
  if (_internal_has_request()) {
    clear_has_command();
      ::sf8xxx_nm::RequestCommand* temp = command_.request_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sf8xxx_nm::RequestCommand& DriverCommand::_internal_request() const {
  return _internal_has_request()
      ? *command_.request_
      : reinterpret_cast< ::sf8xxx_nm::RequestCommand&>(::sf8xxx_nm::_RequestCommand_default_instance_);
}
inline const ::sf8xxx_nm::RequestCommand& DriverCommand::request() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverCommand.request)
  return _internal_request();
}
inline ::sf8xxx_nm::RequestCommand* DriverCommand::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sf8xxx_nm.DriverCommand.request)
  if (_internal_has_request()) {
    clear_has_command();
    ::sf8xxx_nm::RequestCommand* temp = command_.request_;
    command_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DriverCommand::unsafe_arena_set_allocated_request(::sf8xxx_nm::RequestCommand* request) {
  clear_command();
  if (request) {
    set_has_request();
    command_.request_ = request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverCommand.request)
}
inline ::sf8xxx_nm::RequestCommand* DriverCommand::_internal_mutable_request() {
  if (!_internal_has_request()) {
    clear_command();
    set_has_request();
    command_.request_ = CreateMaybeMessage< ::sf8xxx_nm::RequestCommand >(GetArena());
  }
  return command_.request_;
}
inline ::sf8xxx_nm::RequestCommand* DriverCommand::mutable_request() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverCommand.request)
  return _internal_mutable_request();
}

// .sf8xxx_nm.ActionCommand action = 3;
inline bool DriverCommand::_internal_has_action() const {
  return command_case() == kAction;
}
inline bool DriverCommand::has_action() const {
  return _internal_has_action();
}
inline void DriverCommand::set_has_action() {
  _oneof_case_[0] = kAction;
}
inline void DriverCommand::clear_action() {
  if (_internal_has_action()) {
    if (GetArena() == nullptr) {
      delete command_.action_;
    }
    clear_has_command();
  }
}
inline ::sf8xxx_nm::ActionCommand* DriverCommand::release_action() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverCommand.action)
  if (_internal_has_action()) {
    clear_has_command();
      ::sf8xxx_nm::ActionCommand* temp = command_.action_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    command_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sf8xxx_nm::ActionCommand& DriverCommand::_internal_action() const {
  return _internal_has_action()
      ? *command_.action_
      : reinterpret_cast< ::sf8xxx_nm::ActionCommand&>(::sf8xxx_nm::_ActionCommand_default_instance_);
}
inline const ::sf8xxx_nm::ActionCommand& DriverCommand::action() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverCommand.action)
  return _internal_action();
}
inline ::sf8xxx_nm::ActionCommand* DriverCommand::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sf8xxx_nm.DriverCommand.action)
  if (_internal_has_action()) {
    clear_has_command();
    ::sf8xxx_nm::ActionCommand* temp = command_.action_;
    command_.action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DriverCommand::unsafe_arena_set_allocated_action(::sf8xxx_nm::ActionCommand* action) {
  clear_command();
  if (action) {
    set_has_action();
    command_.action_ = action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverCommand.action)
}
inline ::sf8xxx_nm::ActionCommand* DriverCommand::_internal_mutable_action() {
  if (!_internal_has_action()) {
    clear_command();
    set_has_action();
    command_.action_ = CreateMaybeMessage< ::sf8xxx_nm::ActionCommand >(GetArena());
  }
  return command_.action_;
}
inline ::sf8xxx_nm::ActionCommand* DriverCommand::mutable_action() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverCommand.action)
  return _internal_mutable_action();
}

inline bool DriverCommand::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void DriverCommand::clear_has_command() {
  _oneof_case_[0] = COMMAND_NOT_SET;
}
inline DriverCommand::CommandCase DriverCommand::command_case() const {
  return DriverCommand::CommandCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// DriverResponse

// .sf8xxx_nm.ErrorCode error_code = 1;
inline bool DriverResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DriverResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void DriverResponse::clear_error_code() {
  error_code_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::sf8xxx_nm::ErrorCode DriverResponse::_internal_error_code() const {
  return static_cast< ::sf8xxx_nm::ErrorCode >(error_code_);
}
inline ::sf8xxx_nm::ErrorCode DriverResponse::error_code() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.error_code)
  return _internal_error_code();
}
inline void DriverResponse::_internal_set_error_code(::sf8xxx_nm::ErrorCode value) {
  _has_bits_[0] |= 0x00000020u;
  error_code_ = value;
}
inline void DriverResponse::set_error_code(::sf8xxx_nm::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverResponse.error_code)
}

// .sf8xxx_nm.LddStatus ldd_status = 2;
inline bool DriverResponse::_internal_has_ldd_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ldd_status_ != nullptr);
  return value;
}
inline bool DriverResponse::has_ldd_status() const {
  return _internal_has_ldd_status();
}
inline void DriverResponse::clear_ldd_status() {
  if (GetArena() == nullptr && ldd_status_ != nullptr) {
    delete ldd_status_;
  }
  ldd_status_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sf8xxx_nm::LddStatus& DriverResponse::_internal_ldd_status() const {
  const ::sf8xxx_nm::LddStatus* p = ldd_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::LddStatus&>(
      ::sf8xxx_nm::_LddStatus_default_instance_);
}
inline const ::sf8xxx_nm::LddStatus& DriverResponse::ldd_status() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.ldd_status)
  return _internal_ldd_status();
}
inline void DriverResponse::unsafe_arena_set_allocated_ldd_status(
    ::sf8xxx_nm::LddStatus* ldd_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldd_status_);
  }
  ldd_status_ = ldd_status;
  if (ldd_status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverResponse.ldd_status)
}
inline ::sf8xxx_nm::LddStatus* DriverResponse::release_ldd_status() {
  _has_bits_[0] &= ~0x00000001u;
  ::sf8xxx_nm::LddStatus* temp = ldd_status_;
  ldd_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::LddStatus* DriverResponse::unsafe_arena_release_ldd_status() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverResponse.ldd_status)
  _has_bits_[0] &= ~0x00000001u;
  ::sf8xxx_nm::LddStatus* temp = ldd_status_;
  ldd_status_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::LddStatus* DriverResponse::_internal_mutable_ldd_status() {
  _has_bits_[0] |= 0x00000001u;
  if (ldd_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::LddStatus>(GetArena());
    ldd_status_ = p;
  }
  return ldd_status_;
}
inline ::sf8xxx_nm::LddStatus* DriverResponse::mutable_ldd_status() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverResponse.ldd_status)
  return _internal_mutable_ldd_status();
}
inline void DriverResponse::set_allocated_ldd_status(::sf8xxx_nm::LddStatus* ldd_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ldd_status_;
  }
  if (ldd_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ldd_status);
    if (message_arena != submessage_arena) {
      ldd_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldd_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ldd_status_ = ldd_status;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverResponse.ldd_status)
}

// .sf8xxx_nm.TecStatus tec_status = 3;
inline bool DriverResponse::_internal_has_tec_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tec_status_ != nullptr);
  return value;
}
inline bool DriverResponse::has_tec_status() const {
  return _internal_has_tec_status();
}
inline void DriverResponse::clear_tec_status() {
  if (GetArena() == nullptr && tec_status_ != nullptr) {
    delete tec_status_;
  }
  tec_status_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sf8xxx_nm::TecStatus& DriverResponse::_internal_tec_status() const {
  const ::sf8xxx_nm::TecStatus* p = tec_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::TecStatus&>(
      ::sf8xxx_nm::_TecStatus_default_instance_);
}
inline const ::sf8xxx_nm::TecStatus& DriverResponse::tec_status() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.tec_status)
  return _internal_tec_status();
}
inline void DriverResponse::unsafe_arena_set_allocated_tec_status(
    ::sf8xxx_nm::TecStatus* tec_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tec_status_);
  }
  tec_status_ = tec_status;
  if (tec_status) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverResponse.tec_status)
}
inline ::sf8xxx_nm::TecStatus* DriverResponse::release_tec_status() {
  _has_bits_[0] &= ~0x00000002u;
  ::sf8xxx_nm::TecStatus* temp = tec_status_;
  tec_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::TecStatus* DriverResponse::unsafe_arena_release_tec_status() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverResponse.tec_status)
  _has_bits_[0] &= ~0x00000002u;
  ::sf8xxx_nm::TecStatus* temp = tec_status_;
  tec_status_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::TecStatus* DriverResponse::_internal_mutable_tec_status() {
  _has_bits_[0] |= 0x00000002u;
  if (tec_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::TecStatus>(GetArena());
    tec_status_ = p;
  }
  return tec_status_;
}
inline ::sf8xxx_nm::TecStatus* DriverResponse::mutable_tec_status() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverResponse.tec_status)
  return _internal_mutable_tec_status();
}
inline void DriverResponse::set_allocated_tec_status(::sf8xxx_nm::TecStatus* tec_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tec_status_;
  }
  if (tec_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tec_status);
    if (message_arena != submessage_arena) {
      tec_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tec_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tec_status_ = tec_status;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverResponse.tec_status)
}

// .sf8xxx_nm.DriverStateInfo driver_state = 4;
inline bool DriverResponse::_internal_has_driver_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || driver_state_ != nullptr);
  return value;
}
inline bool DriverResponse::has_driver_state() const {
  return _internal_has_driver_state();
}
inline void DriverResponse::clear_driver_state() {
  if (GetArena() == nullptr && driver_state_ != nullptr) {
    delete driver_state_;
  }
  driver_state_ = nullptr;
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sf8xxx_nm::DriverStateInfo& DriverResponse::_internal_driver_state() const {
  const ::sf8xxx_nm::DriverStateInfo* p = driver_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::DriverStateInfo&>(
      ::sf8xxx_nm::_DriverStateInfo_default_instance_);
}
inline const ::sf8xxx_nm::DriverStateInfo& DriverResponse::driver_state() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.driver_state)
  return _internal_driver_state();
}
inline void DriverResponse::unsafe_arena_set_allocated_driver_state(
    ::sf8xxx_nm::DriverStateInfo* driver_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(driver_state_);
  }
  driver_state_ = driver_state;
  if (driver_state) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverResponse.driver_state)
}
inline ::sf8xxx_nm::DriverStateInfo* DriverResponse::release_driver_state() {
  _has_bits_[0] &= ~0x00000004u;
  ::sf8xxx_nm::DriverStateInfo* temp = driver_state_;
  driver_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::DriverStateInfo* DriverResponse::unsafe_arena_release_driver_state() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverResponse.driver_state)
  _has_bits_[0] &= ~0x00000004u;
  ::sf8xxx_nm::DriverStateInfo* temp = driver_state_;
  driver_state_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::DriverStateInfo* DriverResponse::_internal_mutable_driver_state() {
  _has_bits_[0] |= 0x00000004u;
  if (driver_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::DriverStateInfo>(GetArena());
    driver_state_ = p;
  }
  return driver_state_;
}
inline ::sf8xxx_nm::DriverStateInfo* DriverResponse::mutable_driver_state() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverResponse.driver_state)
  return _internal_mutable_driver_state();
}
inline void DriverResponse::set_allocated_driver_state(::sf8xxx_nm::DriverStateInfo* driver_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete driver_state_;
  }
  if (driver_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(driver_state);
    if (message_arena != submessage_arena) {
      driver_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, driver_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  driver_state_ = driver_state;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverResponse.driver_state)
}

// .sf8xxx_nm.TecStateInfo tec_state = 5;
inline bool DriverResponse::_internal_has_tec_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || tec_state_ != nullptr);
  return value;
}
inline bool DriverResponse::has_tec_state() const {
  return _internal_has_tec_state();
}
inline void DriverResponse::clear_tec_state() {
  if (GetArena() == nullptr && tec_state_ != nullptr) {
    delete tec_state_;
  }
  tec_state_ = nullptr;
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sf8xxx_nm::TecStateInfo& DriverResponse::_internal_tec_state() const {
  const ::sf8xxx_nm::TecStateInfo* p = tec_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::TecStateInfo&>(
      ::sf8xxx_nm::_TecStateInfo_default_instance_);
}
inline const ::sf8xxx_nm::TecStateInfo& DriverResponse::tec_state() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.tec_state)
  return _internal_tec_state();
}
inline void DriverResponse::unsafe_arena_set_allocated_tec_state(
    ::sf8xxx_nm::TecStateInfo* tec_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tec_state_);
  }
  tec_state_ = tec_state;
  if (tec_state) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverResponse.tec_state)
}
inline ::sf8xxx_nm::TecStateInfo* DriverResponse::release_tec_state() {
  _has_bits_[0] &= ~0x00000008u;
  ::sf8xxx_nm::TecStateInfo* temp = tec_state_;
  tec_state_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::TecStateInfo* DriverResponse::unsafe_arena_release_tec_state() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverResponse.tec_state)
  _has_bits_[0] &= ~0x00000008u;
  ::sf8xxx_nm::TecStateInfo* temp = tec_state_;
  tec_state_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::TecStateInfo* DriverResponse::_internal_mutable_tec_state() {
  _has_bits_[0] |= 0x00000008u;
  if (tec_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::TecStateInfo>(GetArena());
    tec_state_ = p;
  }
  return tec_state_;
}
inline ::sf8xxx_nm::TecStateInfo* DriverResponse::mutable_tec_state() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverResponse.tec_state)
  return _internal_mutable_tec_state();
}
inline void DriverResponse::set_allocated_tec_state(::sf8xxx_nm::TecStateInfo* tec_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tec_state_;
  }
  if (tec_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tec_state);
    if (message_arena != submessage_arena) {
      tec_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tec_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tec_state_ = tec_state;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverResponse.tec_state)
}

// .sf8xxx_nm.LockStatusInfo lock_status = 6;
inline bool DriverResponse::_internal_has_lock_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || lock_status_ != nullptr);
  return value;
}
inline bool DriverResponse::has_lock_status() const {
  return _internal_has_lock_status();
}
inline void DriverResponse::clear_lock_status() {
  if (GetArena() == nullptr && lock_status_ != nullptr) {
    delete lock_status_;
  }
  lock_status_ = nullptr;
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sf8xxx_nm::LockStatusInfo& DriverResponse::_internal_lock_status() const {
  const ::sf8xxx_nm::LockStatusInfo* p = lock_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::LockStatusInfo&>(
      ::sf8xxx_nm::_LockStatusInfo_default_instance_);
}
inline const ::sf8xxx_nm::LockStatusInfo& DriverResponse::lock_status() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.lock_status)
  return _internal_lock_status();
}
inline void DriverResponse::unsafe_arena_set_allocated_lock_status(
    ::sf8xxx_nm::LockStatusInfo* lock_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock_status_);
  }
  lock_status_ = lock_status;
  if (lock_status) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.DriverResponse.lock_status)
}
inline ::sf8xxx_nm::LockStatusInfo* DriverResponse::release_lock_status() {
  _has_bits_[0] &= ~0x00000010u;
  ::sf8xxx_nm::LockStatusInfo* temp = lock_status_;
  lock_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::LockStatusInfo* DriverResponse::unsafe_arena_release_lock_status() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.DriverResponse.lock_status)
  _has_bits_[0] &= ~0x00000010u;
  ::sf8xxx_nm::LockStatusInfo* temp = lock_status_;
  lock_status_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::LockStatusInfo* DriverResponse::_internal_mutable_lock_status() {
  _has_bits_[0] |= 0x00000010u;
  if (lock_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::LockStatusInfo>(GetArena());
    lock_status_ = p;
  }
  return lock_status_;
}
inline ::sf8xxx_nm::LockStatusInfo* DriverResponse::mutable_lock_status() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.DriverResponse.lock_status)
  return _internal_mutable_lock_status();
}
inline void DriverResponse::set_allocated_lock_status(::sf8xxx_nm::LockStatusInfo* lock_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lock_status_;
  }
  if (lock_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lock_status);
    if (message_arena != submessage_arena) {
      lock_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lock_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  lock_status_ = lock_status;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverResponse.lock_status)
}

// uint32 serial_number = 7;
inline bool DriverResponse::_internal_has_serial_number() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DriverResponse::has_serial_number() const {
  return _internal_has_serial_number();
}
inline void DriverResponse::clear_serial_number() {
  serial_number_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DriverResponse::_internal_serial_number() const {
  return serial_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DriverResponse::serial_number() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverResponse.serial_number)
  return _internal_serial_number();
}
inline void DriverResponse::_internal_set_serial_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  serial_number_ = value;
}
inline void DriverResponse::set_serial_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_serial_number(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverResponse.serial_number)
}

// -------------------------------------------------------------------

// ConfigureCommand

// .sf8xxx_nm.LddSettings ldd_settings = 1;
inline bool ConfigureCommand::_internal_has_ldd_settings() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ldd_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_ldd_settings() const {
  return _internal_has_ldd_settings();
}
inline void ConfigureCommand::clear_ldd_settings() {
  if (GetArena() == nullptr && ldd_settings_ != nullptr) {
    delete ldd_settings_;
  }
  ldd_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sf8xxx_nm::LddSettings& ConfigureCommand::_internal_ldd_settings() const {
  const ::sf8xxx_nm::LddSettings* p = ldd_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::LddSettings&>(
      ::sf8xxx_nm::_LddSettings_default_instance_);
}
inline const ::sf8xxx_nm::LddSettings& ConfigureCommand::ldd_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.ldd_settings)
  return _internal_ldd_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_ldd_settings(
    ::sf8xxx_nm::LddSettings* ldd_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldd_settings_);
  }
  ldd_settings_ = ldd_settings;
  if (ldd_settings) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.ldd_settings)
}
inline ::sf8xxx_nm::LddSettings* ConfigureCommand::release_ldd_settings() {
  _has_bits_[0] &= ~0x00000001u;
  ::sf8xxx_nm::LddSettings* temp = ldd_settings_;
  ldd_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::LddSettings* ConfigureCommand::unsafe_arena_release_ldd_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.ldd_settings)
  _has_bits_[0] &= ~0x00000001u;
  ::sf8xxx_nm::LddSettings* temp = ldd_settings_;
  ldd_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::LddSettings* ConfigureCommand::_internal_mutable_ldd_settings() {
  _has_bits_[0] |= 0x00000001u;
  if (ldd_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::LddSettings>(GetArena());
    ldd_settings_ = p;
  }
  return ldd_settings_;
}
inline ::sf8xxx_nm::LddSettings* ConfigureCommand::mutable_ldd_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.ldd_settings)
  return _internal_mutable_ldd_settings();
}
inline void ConfigureCommand::set_allocated_ldd_settings(::sf8xxx_nm::LddSettings* ldd_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ldd_settings_;
  }
  if (ldd_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ldd_settings);
    if (message_arena != submessage_arena) {
      ldd_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldd_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ldd_settings_ = ldd_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.ldd_settings)
}

// .sf8xxx_nm.TecSettings tec_settings = 2;
inline bool ConfigureCommand::_internal_has_tec_settings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tec_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_tec_settings() const {
  return _internal_has_tec_settings();
}
inline void ConfigureCommand::clear_tec_settings() {
  if (GetArena() == nullptr && tec_settings_ != nullptr) {
    delete tec_settings_;
  }
  tec_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sf8xxx_nm::TecSettings& ConfigureCommand::_internal_tec_settings() const {
  const ::sf8xxx_nm::TecSettings* p = tec_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::TecSettings&>(
      ::sf8xxx_nm::_TecSettings_default_instance_);
}
inline const ::sf8xxx_nm::TecSettings& ConfigureCommand::tec_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.tec_settings)
  return _internal_tec_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_tec_settings(
    ::sf8xxx_nm::TecSettings* tec_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tec_settings_);
  }
  tec_settings_ = tec_settings;
  if (tec_settings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.tec_settings)
}
inline ::sf8xxx_nm::TecSettings* ConfigureCommand::release_tec_settings() {
  _has_bits_[0] &= ~0x00000002u;
  ::sf8xxx_nm::TecSettings* temp = tec_settings_;
  tec_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::TecSettings* ConfigureCommand::unsafe_arena_release_tec_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.tec_settings)
  _has_bits_[0] &= ~0x00000002u;
  ::sf8xxx_nm::TecSettings* temp = tec_settings_;
  tec_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::TecSettings* ConfigureCommand::_internal_mutable_tec_settings() {
  _has_bits_[0] |= 0x00000002u;
  if (tec_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::TecSettings>(GetArena());
    tec_settings_ = p;
  }
  return tec_settings_;
}
inline ::sf8xxx_nm::TecSettings* ConfigureCommand::mutable_tec_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.tec_settings)
  return _internal_mutable_tec_settings();
}
inline void ConfigureCommand::set_allocated_tec_settings(::sf8xxx_nm::TecSettings* tec_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tec_settings_;
  }
  if (tec_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tec_settings);
    if (message_arena != submessage_arena) {
      tec_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tec_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tec_settings_ = tec_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.tec_settings)
}

// .sf8xxx_nm.PidSettings pid_settings = 3;
inline bool ConfigureCommand::_internal_has_pid_settings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || pid_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_pid_settings() const {
  return _internal_has_pid_settings();
}
inline void ConfigureCommand::clear_pid_settings() {
  if (GetArena() == nullptr && pid_settings_ != nullptr) {
    delete pid_settings_;
  }
  pid_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sf8xxx_nm::PidSettings& ConfigureCommand::_internal_pid_settings() const {
  const ::sf8xxx_nm::PidSettings* p = pid_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::PidSettings&>(
      ::sf8xxx_nm::_PidSettings_default_instance_);
}
inline const ::sf8xxx_nm::PidSettings& ConfigureCommand::pid_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.pid_settings)
  return _internal_pid_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_pid_settings(
    ::sf8xxx_nm::PidSettings* pid_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pid_settings_);
  }
  pid_settings_ = pid_settings;
  if (pid_settings) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.pid_settings)
}
inline ::sf8xxx_nm::PidSettings* ConfigureCommand::release_pid_settings() {
  _has_bits_[0] &= ~0x00000004u;
  ::sf8xxx_nm::PidSettings* temp = pid_settings_;
  pid_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::PidSettings* ConfigureCommand::unsafe_arena_release_pid_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.pid_settings)
  _has_bits_[0] &= ~0x00000004u;
  ::sf8xxx_nm::PidSettings* temp = pid_settings_;
  pid_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::PidSettings* ConfigureCommand::_internal_mutable_pid_settings() {
  _has_bits_[0] |= 0x00000004u;
  if (pid_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::PidSettings>(GetArena());
    pid_settings_ = p;
  }
  return pid_settings_;
}
inline ::sf8xxx_nm::PidSettings* ConfigureCommand::mutable_pid_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.pid_settings)
  return _internal_mutable_pid_settings();
}
inline void ConfigureCommand::set_allocated_pid_settings(::sf8xxx_nm::PidSettings* pid_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pid_settings_;
  }
  if (pid_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pid_settings);
    if (message_arena != submessage_arena) {
      pid_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pid_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pid_settings_ = pid_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.pid_settings)
}

// .sf8xxx_nm.NtcInterlockSettings ntc_interlock_settings = 4;
inline bool ConfigureCommand::_internal_has_ntc_interlock_settings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ntc_interlock_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_ntc_interlock_settings() const {
  return _internal_has_ntc_interlock_settings();
}
inline void ConfigureCommand::clear_ntc_interlock_settings() {
  if (GetArena() == nullptr && ntc_interlock_settings_ != nullptr) {
    delete ntc_interlock_settings_;
  }
  ntc_interlock_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sf8xxx_nm::NtcInterlockSettings& ConfigureCommand::_internal_ntc_interlock_settings() const {
  const ::sf8xxx_nm::NtcInterlockSettings* p = ntc_interlock_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::NtcInterlockSettings&>(
      ::sf8xxx_nm::_NtcInterlockSettings_default_instance_);
}
inline const ::sf8xxx_nm::NtcInterlockSettings& ConfigureCommand::ntc_interlock_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.ntc_interlock_settings)
  return _internal_ntc_interlock_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_ntc_interlock_settings(
    ::sf8xxx_nm::NtcInterlockSettings* ntc_interlock_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ntc_interlock_settings_);
  }
  ntc_interlock_settings_ = ntc_interlock_settings;
  if (ntc_interlock_settings) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.ntc_interlock_settings)
}
inline ::sf8xxx_nm::NtcInterlockSettings* ConfigureCommand::release_ntc_interlock_settings() {
  _has_bits_[0] &= ~0x00000008u;
  ::sf8xxx_nm::NtcInterlockSettings* temp = ntc_interlock_settings_;
  ntc_interlock_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::NtcInterlockSettings* ConfigureCommand::unsafe_arena_release_ntc_interlock_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.ntc_interlock_settings)
  _has_bits_[0] &= ~0x00000008u;
  ::sf8xxx_nm::NtcInterlockSettings* temp = ntc_interlock_settings_;
  ntc_interlock_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::NtcInterlockSettings* ConfigureCommand::_internal_mutable_ntc_interlock_settings() {
  _has_bits_[0] |= 0x00000008u;
  if (ntc_interlock_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::NtcInterlockSettings>(GetArena());
    ntc_interlock_settings_ = p;
  }
  return ntc_interlock_settings_;
}
inline ::sf8xxx_nm::NtcInterlockSettings* ConfigureCommand::mutable_ntc_interlock_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.ntc_interlock_settings)
  return _internal_mutable_ntc_interlock_settings();
}
inline void ConfigureCommand::set_allocated_ntc_interlock_settings(::sf8xxx_nm::NtcInterlockSettings* ntc_interlock_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ntc_interlock_settings_;
  }
  if (ntc_interlock_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ntc_interlock_settings);
    if (message_arena != submessage_arena) {
      ntc_interlock_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ntc_interlock_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ntc_interlock_settings_ = ntc_interlock_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.ntc_interlock_settings)
}

// .sf8xxx_nm.DriverStateSettings driver_state_settings = 5;
inline bool ConfigureCommand::_internal_has_driver_state_settings() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || driver_state_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_driver_state_settings() const {
  return _internal_has_driver_state_settings();
}
inline void ConfigureCommand::clear_driver_state_settings() {
  if (GetArena() == nullptr && driver_state_settings_ != nullptr) {
    delete driver_state_settings_;
  }
  driver_state_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sf8xxx_nm::DriverStateSettings& ConfigureCommand::_internal_driver_state_settings() const {
  const ::sf8xxx_nm::DriverStateSettings* p = driver_state_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::DriverStateSettings&>(
      ::sf8xxx_nm::_DriverStateSettings_default_instance_);
}
inline const ::sf8xxx_nm::DriverStateSettings& ConfigureCommand::driver_state_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.driver_state_settings)
  return _internal_driver_state_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_driver_state_settings(
    ::sf8xxx_nm::DriverStateSettings* driver_state_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(driver_state_settings_);
  }
  driver_state_settings_ = driver_state_settings;
  if (driver_state_settings) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.driver_state_settings)
}
inline ::sf8xxx_nm::DriverStateSettings* ConfigureCommand::release_driver_state_settings() {
  _has_bits_[0] &= ~0x00000010u;
  ::sf8xxx_nm::DriverStateSettings* temp = driver_state_settings_;
  driver_state_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::DriverStateSettings* ConfigureCommand::unsafe_arena_release_driver_state_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.driver_state_settings)
  _has_bits_[0] &= ~0x00000010u;
  ::sf8xxx_nm::DriverStateSettings* temp = driver_state_settings_;
  driver_state_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::DriverStateSettings* ConfigureCommand::_internal_mutable_driver_state_settings() {
  _has_bits_[0] |= 0x00000010u;
  if (driver_state_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::DriverStateSettings>(GetArena());
    driver_state_settings_ = p;
  }
  return driver_state_settings_;
}
inline ::sf8xxx_nm::DriverStateSettings* ConfigureCommand::mutable_driver_state_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.driver_state_settings)
  return _internal_mutable_driver_state_settings();
}
inline void ConfigureCommand::set_allocated_driver_state_settings(::sf8xxx_nm::DriverStateSettings* driver_state_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete driver_state_settings_;
  }
  if (driver_state_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(driver_state_settings);
    if (message_arena != submessage_arena) {
      driver_state_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, driver_state_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  driver_state_settings_ = driver_state_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.driver_state_settings)
}

// .sf8xxx_nm.TecStateSettings tec_state_settings = 6;
inline bool ConfigureCommand::_internal_has_tec_state_settings() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || tec_state_settings_ != nullptr);
  return value;
}
inline bool ConfigureCommand::has_tec_state_settings() const {
  return _internal_has_tec_state_settings();
}
inline void ConfigureCommand::clear_tec_state_settings() {
  if (GetArena() == nullptr && tec_state_settings_ != nullptr) {
    delete tec_state_settings_;
  }
  tec_state_settings_ = nullptr;
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::sf8xxx_nm::TecStateSettings& ConfigureCommand::_internal_tec_state_settings() const {
  const ::sf8xxx_nm::TecStateSettings* p = tec_state_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::sf8xxx_nm::TecStateSettings&>(
      ::sf8xxx_nm::_TecStateSettings_default_instance_);
}
inline const ::sf8xxx_nm::TecStateSettings& ConfigureCommand::tec_state_settings() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ConfigureCommand.tec_state_settings)
  return _internal_tec_state_settings();
}
inline void ConfigureCommand::unsafe_arena_set_allocated_tec_state_settings(
    ::sf8xxx_nm::TecStateSettings* tec_state_settings) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tec_state_settings_);
  }
  tec_state_settings_ = tec_state_settings;
  if (tec_state_settings) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sf8xxx_nm.ConfigureCommand.tec_state_settings)
}
inline ::sf8xxx_nm::TecStateSettings* ConfigureCommand::release_tec_state_settings() {
  _has_bits_[0] &= ~0x00000020u;
  ::sf8xxx_nm::TecStateSettings* temp = tec_state_settings_;
  tec_state_settings_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sf8xxx_nm::TecStateSettings* ConfigureCommand::unsafe_arena_release_tec_state_settings() {
  // @@protoc_insertion_point(field_release:sf8xxx_nm.ConfigureCommand.tec_state_settings)
  _has_bits_[0] &= ~0x00000020u;
  ::sf8xxx_nm::TecStateSettings* temp = tec_state_settings_;
  tec_state_settings_ = nullptr;
  return temp;
}
inline ::sf8xxx_nm::TecStateSettings* ConfigureCommand::_internal_mutable_tec_state_settings() {
  _has_bits_[0] |= 0x00000020u;
  if (tec_state_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::sf8xxx_nm::TecStateSettings>(GetArena());
    tec_state_settings_ = p;
  }
  return tec_state_settings_;
}
inline ::sf8xxx_nm::TecStateSettings* ConfigureCommand::mutable_tec_state_settings() {
  // @@protoc_insertion_point(field_mutable:sf8xxx_nm.ConfigureCommand.tec_state_settings)
  return _internal_mutable_tec_state_settings();
}
inline void ConfigureCommand::set_allocated_tec_state_settings(::sf8xxx_nm::TecStateSettings* tec_state_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tec_state_settings_;
  }
  if (tec_state_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tec_state_settings);
    if (message_arena != submessage_arena) {
      tec_state_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tec_state_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  tec_state_settings_ = tec_state_settings;
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.ConfigureCommand.tec_state_settings)
}

// -------------------------------------------------------------------

// LddSettings

// float frequency_hz = 1;
inline bool LddSettings::_internal_has_frequency_hz() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LddSettings::has_frequency_hz() const {
  return _internal_has_frequency_hz();
}
inline void LddSettings::clear_frequency_hz() {
  frequency_hz_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float LddSettings::_internal_frequency_hz() const {
  return frequency_hz_;
}
inline float LddSettings::frequency_hz() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddSettings.frequency_hz)
  return _internal_frequency_hz();
}
inline void LddSettings::_internal_set_frequency_hz(float value) {
  _has_bits_[0] |= 0x00000001u;
  frequency_hz_ = value;
}
inline void LddSettings::set_frequency_hz(float value) {
  _internal_set_frequency_hz(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddSettings.frequency_hz)
}

// float duration_ms = 2;
inline bool LddSettings::_internal_has_duration_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LddSettings::has_duration_ms() const {
  return _internal_has_duration_ms();
}
inline void LddSettings::clear_duration_ms() {
  duration_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float LddSettings::_internal_duration_ms() const {
  return duration_ms_;
}
inline float LddSettings::duration_ms() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddSettings.duration_ms)
  return _internal_duration_ms();
}
inline void LddSettings::_internal_set_duration_ms(float value) {
  _has_bits_[0] |= 0x00000002u;
  duration_ms_ = value;
}
inline void LddSettings::set_duration_ms(float value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddSettings.duration_ms)
}

// float current_ma = 3;
inline bool LddSettings::_internal_has_current_ma() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LddSettings::has_current_ma() const {
  return _internal_has_current_ma();
}
inline void LddSettings::clear_current_ma() {
  current_ma_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LddSettings::_internal_current_ma() const {
  return current_ma_;
}
inline float LddSettings::current_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddSettings.current_ma)
  return _internal_current_ma();
}
inline void LddSettings::_internal_set_current_ma(float value) {
  _has_bits_[0] |= 0x00000004u;
  current_ma_ = value;
}
inline void LddSettings::set_current_ma(float value) {
  _internal_set_current_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddSettings.current_ma)
}

// float current_max_ma = 4;
inline bool LddSettings::_internal_has_current_max_ma() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LddSettings::has_current_max_ma() const {
  return _internal_has_current_max_ma();
}
inline void LddSettings::clear_current_max_ma() {
  current_max_ma_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LddSettings::_internal_current_max_ma() const {
  return current_max_ma_;
}
inline float LddSettings::current_max_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddSettings.current_max_ma)
  return _internal_current_max_ma();
}
inline void LddSettings::_internal_set_current_max_ma(float value) {
  _has_bits_[0] |= 0x00000008u;
  current_max_ma_ = value;
}
inline void LddSettings::set_current_max_ma(float value) {
  _internal_set_current_max_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddSettings.current_max_ma)
}

// float current_calibration_percent = 5;
inline bool LddSettings::_internal_has_current_calibration_percent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LddSettings::has_current_calibration_percent() const {
  return _internal_has_current_calibration_percent();
}
inline void LddSettings::clear_current_calibration_percent() {
  current_calibration_percent_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float LddSettings::_internal_current_calibration_percent() const {
  return current_calibration_percent_;
}
inline float LddSettings::current_calibration_percent() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddSettings.current_calibration_percent)
  return _internal_current_calibration_percent();
}
inline void LddSettings::_internal_set_current_calibration_percent(float value) {
  _has_bits_[0] |= 0x00000010u;
  current_calibration_percent_ = value;
}
inline void LddSettings::set_current_calibration_percent(float value) {
  _internal_set_current_calibration_percent(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddSettings.current_calibration_percent)
}

// -------------------------------------------------------------------

// TecSettings

// float temperature_celsius = 1;
inline bool TecSettings::_internal_has_temperature_celsius() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TecSettings::has_temperature_celsius() const {
  return _internal_has_temperature_celsius();
}
inline void TecSettings::clear_temperature_celsius() {
  temperature_celsius_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float TecSettings::_internal_temperature_celsius() const {
  return temperature_celsius_;
}
inline float TecSettings::temperature_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.temperature_celsius)
  return _internal_temperature_celsius();
}
inline void TecSettings::_internal_set_temperature_celsius(float value) {
  _has_bits_[0] |= 0x00000001u;
  temperature_celsius_ = value;
}
inline void TecSettings::set_temperature_celsius(float value) {
  _internal_set_temperature_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.temperature_celsius)
}

// float temp_max_celsius = 2;
inline bool TecSettings::_internal_has_temp_max_celsius() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TecSettings::has_temp_max_celsius() const {
  return _internal_has_temp_max_celsius();
}
inline void TecSettings::clear_temp_max_celsius() {
  temp_max_celsius_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float TecSettings::_internal_temp_max_celsius() const {
  return temp_max_celsius_;
}
inline float TecSettings::temp_max_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.temp_max_celsius)
  return _internal_temp_max_celsius();
}
inline void TecSettings::_internal_set_temp_max_celsius(float value) {
  _has_bits_[0] |= 0x00000002u;
  temp_max_celsius_ = value;
}
inline void TecSettings::set_temp_max_celsius(float value) {
  _internal_set_temp_max_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.temp_max_celsius)
}

// float temp_min_celsius = 3;
inline bool TecSettings::_internal_has_temp_min_celsius() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TecSettings::has_temp_min_celsius() const {
  return _internal_has_temp_min_celsius();
}
inline void TecSettings::clear_temp_min_celsius() {
  temp_min_celsius_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float TecSettings::_internal_temp_min_celsius() const {
  return temp_min_celsius_;
}
inline float TecSettings::temp_min_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.temp_min_celsius)
  return _internal_temp_min_celsius();
}
inline void TecSettings::_internal_set_temp_min_celsius(float value) {
  _has_bits_[0] |= 0x00000004u;
  temp_min_celsius_ = value;
}
inline void TecSettings::set_temp_min_celsius(float value) {
  _internal_set_temp_min_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.temp_min_celsius)
}

// float current_limit_a = 4;
inline bool TecSettings::_internal_has_current_limit_a() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TecSettings::has_current_limit_a() const {
  return _internal_has_current_limit_a();
}
inline void TecSettings::clear_current_limit_a() {
  current_limit_a_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float TecSettings::_internal_current_limit_a() const {
  return current_limit_a_;
}
inline float TecSettings::current_limit_a() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.current_limit_a)
  return _internal_current_limit_a();
}
inline void TecSettings::_internal_set_current_limit_a(float value) {
  _has_bits_[0] |= 0x00000008u;
  current_limit_a_ = value;
}
inline void TecSettings::set_current_limit_a(float value) {
  _internal_set_current_limit_a(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.current_limit_a)
}

// float calibration_percent = 5;
inline bool TecSettings::_internal_has_calibration_percent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TecSettings::has_calibration_percent() const {
  return _internal_has_calibration_percent();
}
inline void TecSettings::clear_calibration_percent() {
  calibration_percent_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float TecSettings::_internal_calibration_percent() const {
  return calibration_percent_;
}
inline float TecSettings::calibration_percent() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.calibration_percent)
  return _internal_calibration_percent();
}
inline void TecSettings::_internal_set_calibration_percent(float value) {
  _has_bits_[0] |= 0x00000010u;
  calibration_percent_ = value;
}
inline void TecSettings::set_calibration_percent(float value) {
  _internal_set_calibration_percent(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.calibration_percent)
}

// uint32 internal_ntc_b_coefficient = 6;
inline bool TecSettings::_internal_has_internal_ntc_b_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TecSettings::has_internal_ntc_b_coefficient() const {
  return _internal_has_internal_ntc_b_coefficient();
}
inline void TecSettings::clear_internal_ntc_b_coefficient() {
  internal_ntc_b_coefficient_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecSettings::_internal_internal_ntc_b_coefficient() const {
  return internal_ntc_b_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecSettings::internal_ntc_b_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecSettings.internal_ntc_b_coefficient)
  return _internal_internal_ntc_b_coefficient();
}
inline void TecSettings::_internal_set_internal_ntc_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  internal_ntc_b_coefficient_ = value;
}
inline void TecSettings::set_internal_ntc_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_internal_ntc_b_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecSettings.internal_ntc_b_coefficient)
}

// -------------------------------------------------------------------

// PidSettings

// uint32 p_coefficient = 1;
inline bool PidSettings::_internal_has_p_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PidSettings::has_p_coefficient() const {
  return _internal_has_p_coefficient();
}
inline void PidSettings::clear_p_coefficient() {
  p_coefficient_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::_internal_p_coefficient() const {
  return p_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::p_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.PidSettings.p_coefficient)
  return _internal_p_coefficient();
}
inline void PidSettings::_internal_set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  p_coefficient_ = value;
}
inline void PidSettings::set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_p_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.PidSettings.p_coefficient)
}

// uint32 i_coefficient = 2;
inline bool PidSettings::_internal_has_i_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PidSettings::has_i_coefficient() const {
  return _internal_has_i_coefficient();
}
inline void PidSettings::clear_i_coefficient() {
  i_coefficient_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::_internal_i_coefficient() const {
  return i_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::i_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.PidSettings.i_coefficient)
  return _internal_i_coefficient();
}
inline void PidSettings::_internal_set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  i_coefficient_ = value;
}
inline void PidSettings::set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_i_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.PidSettings.i_coefficient)
}

// uint32 d_coefficient = 3;
inline bool PidSettings::_internal_has_d_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PidSettings::has_d_coefficient() const {
  return _internal_has_d_coefficient();
}
inline void PidSettings::clear_d_coefficient() {
  d_coefficient_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::_internal_d_coefficient() const {
  return d_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PidSettings::d_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.PidSettings.d_coefficient)
  return _internal_d_coefficient();
}
inline void PidSettings::_internal_set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  d_coefficient_ = value;
}
inline void PidSettings::set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_d_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.PidSettings.d_coefficient)
}

// -------------------------------------------------------------------

// NtcInterlockSettings

// float lower_limit_celsius = 1;
inline bool NtcInterlockSettings::_internal_has_lower_limit_celsius() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NtcInterlockSettings::has_lower_limit_celsius() const {
  return _internal_has_lower_limit_celsius();
}
inline void NtcInterlockSettings::clear_lower_limit_celsius() {
  lower_limit_celsius_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float NtcInterlockSettings::_internal_lower_limit_celsius() const {
  return lower_limit_celsius_;
}
inline float NtcInterlockSettings::lower_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.NtcInterlockSettings.lower_limit_celsius)
  return _internal_lower_limit_celsius();
}
inline void NtcInterlockSettings::_internal_set_lower_limit_celsius(float value) {
  _has_bits_[0] |= 0x00000001u;
  lower_limit_celsius_ = value;
}
inline void NtcInterlockSettings::set_lower_limit_celsius(float value) {
  _internal_set_lower_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.NtcInterlockSettings.lower_limit_celsius)
}

// float upper_limit_celsius = 2;
inline bool NtcInterlockSettings::_internal_has_upper_limit_celsius() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NtcInterlockSettings::has_upper_limit_celsius() const {
  return _internal_has_upper_limit_celsius();
}
inline void NtcInterlockSettings::clear_upper_limit_celsius() {
  upper_limit_celsius_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float NtcInterlockSettings::_internal_upper_limit_celsius() const {
  return upper_limit_celsius_;
}
inline float NtcInterlockSettings::upper_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.NtcInterlockSettings.upper_limit_celsius)
  return _internal_upper_limit_celsius();
}
inline void NtcInterlockSettings::_internal_set_upper_limit_celsius(float value) {
  _has_bits_[0] |= 0x00000002u;
  upper_limit_celsius_ = value;
}
inline void NtcInterlockSettings::set_upper_limit_celsius(float value) {
  _internal_set_upper_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.NtcInterlockSettings.upper_limit_celsius)
}

// uint32 b_coefficient = 3;
inline bool NtcInterlockSettings::_internal_has_b_coefficient() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NtcInterlockSettings::has_b_coefficient() const {
  return _internal_has_b_coefficient();
}
inline void NtcInterlockSettings::clear_b_coefficient() {
  b_coefficient_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NtcInterlockSettings::_internal_b_coefficient() const {
  return b_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NtcInterlockSettings::b_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.NtcInterlockSettings.b_coefficient)
  return _internal_b_coefficient();
}
inline void NtcInterlockSettings::_internal_set_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  b_coefficient_ = value;
}
inline void NtcInterlockSettings::set_b_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_b_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.NtcInterlockSettings.b_coefficient)
}

// -------------------------------------------------------------------

// DriverStateSettings

// .sf8xxx_nm.DriverStateSettings.CurrentSetSource current_set_source = 1;
inline bool DriverStateSettings::_internal_has_current_set_source() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DriverStateSettings::has_current_set_source() const {
  return _internal_has_current_set_source();
}
inline void DriverStateSettings::clear_current_set_source() {
  current_set_source_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::sf8xxx_nm::DriverStateSettings_CurrentSetSource DriverStateSettings::_internal_current_set_source() const {
  return static_cast< ::sf8xxx_nm::DriverStateSettings_CurrentSetSource >(current_set_source_);
}
inline ::sf8xxx_nm::DriverStateSettings_CurrentSetSource DriverStateSettings::current_set_source() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateSettings.current_set_source)
  return _internal_current_set_source();
}
inline void DriverStateSettings::_internal_set_current_set_source(::sf8xxx_nm::DriverStateSettings_CurrentSetSource value) {
  _has_bits_[0] |= 0x00000001u;
  current_set_source_ = value;
}
inline void DriverStateSettings::set_current_set_source(::sf8xxx_nm::DriverStateSettings_CurrentSetSource value) {
  _internal_set_current_set_source(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateSettings.current_set_source)
}

// .sf8xxx_nm.DriverStateSettings.EnableSource enable_source = 2;
inline bool DriverStateSettings::_internal_has_enable_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DriverStateSettings::has_enable_source() const {
  return _internal_has_enable_source();
}
inline void DriverStateSettings::clear_enable_source() {
  enable_source_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sf8xxx_nm::DriverStateSettings_EnableSource DriverStateSettings::_internal_enable_source() const {
  return static_cast< ::sf8xxx_nm::DriverStateSettings_EnableSource >(enable_source_);
}
inline ::sf8xxx_nm::DriverStateSettings_EnableSource DriverStateSettings::enable_source() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateSettings.enable_source)
  return _internal_enable_source();
}
inline void DriverStateSettings::_internal_set_enable_source(::sf8xxx_nm::DriverStateSettings_EnableSource value) {
  _has_bits_[0] |= 0x00000002u;
  enable_source_ = value;
}
inline void DriverStateSettings::set_enable_source(::sf8xxx_nm::DriverStateSettings_EnableSource value) {
  _internal_set_enable_source(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateSettings.enable_source)
}

// .sf8xxx_nm.DriverStateSettings.InterlockPolicy interlock_policy = 3;
inline bool DriverStateSettings::_internal_has_interlock_policy() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DriverStateSettings::has_interlock_policy() const {
  return _internal_has_interlock_policy();
}
inline void DriverStateSettings::clear_interlock_policy() {
  interlock_policy_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::sf8xxx_nm::DriverStateSettings_InterlockPolicy DriverStateSettings::_internal_interlock_policy() const {
  return static_cast< ::sf8xxx_nm::DriverStateSettings_InterlockPolicy >(interlock_policy_);
}
inline ::sf8xxx_nm::DriverStateSettings_InterlockPolicy DriverStateSettings::interlock_policy() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateSettings.interlock_policy)
  return _internal_interlock_policy();
}
inline void DriverStateSettings::_internal_set_interlock_policy(::sf8xxx_nm::DriverStateSettings_InterlockPolicy value) {
  _has_bits_[0] |= 0x00000004u;
  interlock_policy_ = value;
}
inline void DriverStateSettings::set_interlock_policy(::sf8xxx_nm::DriverStateSettings_InterlockPolicy value) {
  _internal_set_interlock_policy(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateSettings.interlock_policy)
}

// .sf8xxx_nm.DriverStateSettings.NtcInterlockPolicy ntc_interlock_policy = 4;
inline bool DriverStateSettings::_internal_has_ntc_interlock_policy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DriverStateSettings::has_ntc_interlock_policy() const {
  return _internal_has_ntc_interlock_policy();
}
inline void DriverStateSettings::clear_ntc_interlock_policy() {
  ntc_interlock_policy_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy DriverStateSettings::_internal_ntc_interlock_policy() const {
  return static_cast< ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy >(ntc_interlock_policy_);
}
inline ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy DriverStateSettings::ntc_interlock_policy() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateSettings.ntc_interlock_policy)
  return _internal_ntc_interlock_policy();
}
inline void DriverStateSettings::_internal_set_ntc_interlock_policy(::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy value) {
  _has_bits_[0] |= 0x00000008u;
  ntc_interlock_policy_ = value;
}
inline void DriverStateSettings::set_ntc_interlock_policy(::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy value) {
  _internal_set_ntc_interlock_policy(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateSettings.ntc_interlock_policy)
}

// -------------------------------------------------------------------

// TecStateSettings

// .sf8xxx_nm.TecStateSettings.TempSetSource temp_set_source = 1;
inline bool TecStateSettings::_internal_has_temp_set_source() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TecStateSettings::has_temp_set_source() const {
  return _internal_has_temp_set_source();
}
inline void TecStateSettings::clear_temp_set_source() {
  temp_set_source_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::sf8xxx_nm::TecStateSettings_TempSetSource TecStateSettings::_internal_temp_set_source() const {
  return static_cast< ::sf8xxx_nm::TecStateSettings_TempSetSource >(temp_set_source_);
}
inline ::sf8xxx_nm::TecStateSettings_TempSetSource TecStateSettings::temp_set_source() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStateSettings.temp_set_source)
  return _internal_temp_set_source();
}
inline void TecStateSettings::_internal_set_temp_set_source(::sf8xxx_nm::TecStateSettings_TempSetSource value) {
  _has_bits_[0] |= 0x00000001u;
  temp_set_source_ = value;
}
inline void TecStateSettings::set_temp_set_source(::sf8xxx_nm::TecStateSettings_TempSetSource value) {
  _internal_set_temp_set_source(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStateSettings.temp_set_source)
}

// .sf8xxx_nm.TecStateSettings.EnableSource enable_source = 2;
inline bool TecStateSettings::_internal_has_enable_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TecStateSettings::has_enable_source() const {
  return _internal_has_enable_source();
}
inline void TecStateSettings::clear_enable_source() {
  enable_source_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sf8xxx_nm::TecStateSettings_EnableSource TecStateSettings::_internal_enable_source() const {
  return static_cast< ::sf8xxx_nm::TecStateSettings_EnableSource >(enable_source_);
}
inline ::sf8xxx_nm::TecStateSettings_EnableSource TecStateSettings::enable_source() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStateSettings.enable_source)
  return _internal_enable_source();
}
inline void TecStateSettings::_internal_set_enable_source(::sf8xxx_nm::TecStateSettings_EnableSource value) {
  _has_bits_[0] |= 0x00000002u;
  enable_source_ = value;
}
inline void TecStateSettings::set_enable_source(::sf8xxx_nm::TecStateSettings_EnableSource value) {
  _internal_set_enable_source(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStateSettings.enable_source)
}

// -------------------------------------------------------------------

// RequestCommand

// repeated .sf8xxx_nm.RequestType requests = 1;
inline int RequestCommand::_internal_requests_size() const {
  return requests_.size();
}
inline int RequestCommand::requests_size() const {
  return _internal_requests_size();
}
inline void RequestCommand::clear_requests() {
  requests_.Clear();
}
inline ::sf8xxx_nm::RequestType RequestCommand::_internal_requests(int index) const {
  return static_cast< ::sf8xxx_nm::RequestType >(requests_.Get(index));
}
inline ::sf8xxx_nm::RequestType RequestCommand::requests(int index) const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.RequestCommand.requests)
  return _internal_requests(index);
}
inline void RequestCommand::set_requests(int index, ::sf8xxx_nm::RequestType value) {
  requests_.Set(index, value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.RequestCommand.requests)
}
inline void RequestCommand::_internal_add_requests(::sf8xxx_nm::RequestType value) {
  requests_.Add(value);
}
inline void RequestCommand::add_requests(::sf8xxx_nm::RequestType value) {
  // @@protoc_insertion_point(field_add:sf8xxx_nm.RequestCommand.requests)
  _internal_add_requests(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
RequestCommand::requests() const {
  // @@protoc_insertion_point(field_list:sf8xxx_nm.RequestCommand.requests)
  return requests_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
RequestCommand::_internal_mutable_requests() {
  return &requests_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
RequestCommand::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:sf8xxx_nm.RequestCommand.requests)
  return _internal_mutable_requests();
}

// -------------------------------------------------------------------

// ActionCommand

// .sf8xxx_nm.ActionType type = 1;
inline void ActionCommand::clear_type() {
  type_ = 0;
}
inline ::sf8xxx_nm::ActionType ActionCommand::_internal_type() const {
  return static_cast< ::sf8xxx_nm::ActionType >(type_);
}
inline ::sf8xxx_nm::ActionType ActionCommand::type() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.ActionCommand.type)
  return _internal_type();
}
inline void ActionCommand::_internal_set_type(::sf8xxx_nm::ActionType value) {
  
  type_ = value;
}
inline void ActionCommand::set_type(::sf8xxx_nm::ActionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.ActionCommand.type)
}

// -------------------------------------------------------------------

// LddStatus

// float frequency_hz = 1;
inline void LddStatus::clear_frequency_hz() {
  frequency_hz_ = 0;
}
inline float LddStatus::_internal_frequency_hz() const {
  return frequency_hz_;
}
inline float LddStatus::frequency_hz() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.frequency_hz)
  return _internal_frequency_hz();
}
inline void LddStatus::_internal_set_frequency_hz(float value) {
  
  frequency_hz_ = value;
}
inline void LddStatus::set_frequency_hz(float value) {
  _internal_set_frequency_hz(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.frequency_hz)
}

// float frequency_min_hz = 2;
inline void LddStatus::clear_frequency_min_hz() {
  frequency_min_hz_ = 0;
}
inline float LddStatus::_internal_frequency_min_hz() const {
  return frequency_min_hz_;
}
inline float LddStatus::frequency_min_hz() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.frequency_min_hz)
  return _internal_frequency_min_hz();
}
inline void LddStatus::_internal_set_frequency_min_hz(float value) {
  
  frequency_min_hz_ = value;
}
inline void LddStatus::set_frequency_min_hz(float value) {
  _internal_set_frequency_min_hz(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.frequency_min_hz)
}

// float frequency_max_hz = 3;
inline void LddStatus::clear_frequency_max_hz() {
  frequency_max_hz_ = 0;
}
inline float LddStatus::_internal_frequency_max_hz() const {
  return frequency_max_hz_;
}
inline float LddStatus::frequency_max_hz() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.frequency_max_hz)
  return _internal_frequency_max_hz();
}
inline void LddStatus::_internal_set_frequency_max_hz(float value) {
  
  frequency_max_hz_ = value;
}
inline void LddStatus::set_frequency_max_hz(float value) {
  _internal_set_frequency_max_hz(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.frequency_max_hz)
}

// float duration_ms = 4;
inline void LddStatus::clear_duration_ms() {
  duration_ms_ = 0;
}
inline float LddStatus::_internal_duration_ms() const {
  return duration_ms_;
}
inline float LddStatus::duration_ms() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.duration_ms)
  return _internal_duration_ms();
}
inline void LddStatus::_internal_set_duration_ms(float value) {
  
  duration_ms_ = value;
}
inline void LddStatus::set_duration_ms(float value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.duration_ms)
}

// float duration_min_ms = 5;
inline void LddStatus::clear_duration_min_ms() {
  duration_min_ms_ = 0;
}
inline float LddStatus::_internal_duration_min_ms() const {
  return duration_min_ms_;
}
inline float LddStatus::duration_min_ms() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.duration_min_ms)
  return _internal_duration_min_ms();
}
inline void LddStatus::_internal_set_duration_min_ms(float value) {
  
  duration_min_ms_ = value;
}
inline void LddStatus::set_duration_min_ms(float value) {
  _internal_set_duration_min_ms(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.duration_min_ms)
}

// float duration_max_ms = 6;
inline void LddStatus::clear_duration_max_ms() {
  duration_max_ms_ = 0;
}
inline float LddStatus::_internal_duration_max_ms() const {
  return duration_max_ms_;
}
inline float LddStatus::duration_max_ms() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.duration_max_ms)
  return _internal_duration_max_ms();
}
inline void LddStatus::_internal_set_duration_max_ms(float value) {
  
  duration_max_ms_ = value;
}
inline void LddStatus::set_duration_max_ms(float value) {
  _internal_set_duration_max_ms(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.duration_max_ms)
}

// float current_ma = 7;
inline void LddStatus::clear_current_ma() {
  current_ma_ = 0;
}
inline float LddStatus::_internal_current_ma() const {
  return current_ma_;
}
inline float LddStatus::current_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_ma)
  return _internal_current_ma();
}
inline void LddStatus::_internal_set_current_ma(float value) {
  
  current_ma_ = value;
}
inline void LddStatus::set_current_ma(float value) {
  _internal_set_current_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_ma)
}

// float current_min_ma = 8;
inline void LddStatus::clear_current_min_ma() {
  current_min_ma_ = 0;
}
inline float LddStatus::_internal_current_min_ma() const {
  return current_min_ma_;
}
inline float LddStatus::current_min_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_min_ma)
  return _internal_current_min_ma();
}
inline void LddStatus::_internal_set_current_min_ma(float value) {
  
  current_min_ma_ = value;
}
inline void LddStatus::set_current_min_ma(float value) {
  _internal_set_current_min_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_min_ma)
}

// float current_max_ma = 9;
inline void LddStatus::clear_current_max_ma() {
  current_max_ma_ = 0;
}
inline float LddStatus::_internal_current_max_ma() const {
  return current_max_ma_;
}
inline float LddStatus::current_max_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_max_ma)
  return _internal_current_max_ma();
}
inline void LddStatus::_internal_set_current_max_ma(float value) {
  
  current_max_ma_ = value;
}
inline void LddStatus::set_current_max_ma(float value) {
  _internal_set_current_max_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_max_ma)
}

// float current_max_limit_ma = 10;
inline void LddStatus::clear_current_max_limit_ma() {
  current_max_limit_ma_ = 0;
}
inline float LddStatus::_internal_current_max_limit_ma() const {
  return current_max_limit_ma_;
}
inline float LddStatus::current_max_limit_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_max_limit_ma)
  return _internal_current_max_limit_ma();
}
inline void LddStatus::_internal_set_current_max_limit_ma(float value) {
  
  current_max_limit_ma_ = value;
}
inline void LddStatus::set_current_max_limit_ma(float value) {
  _internal_set_current_max_limit_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_max_limit_ma)
}

// float measured_current_ma = 11;
inline void LddStatus::clear_measured_current_ma() {
  measured_current_ma_ = 0;
}
inline float LddStatus::_internal_measured_current_ma() const {
  return measured_current_ma_;
}
inline float LddStatus::measured_current_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.measured_current_ma)
  return _internal_measured_current_ma();
}
inline void LddStatus::_internal_set_measured_current_ma(float value) {
  
  measured_current_ma_ = value;
}
inline void LddStatus::set_measured_current_ma(float value) {
  _internal_set_measured_current_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.measured_current_ma)
}

// float current_protection_threshold_ma = 12;
inline void LddStatus::clear_current_protection_threshold_ma() {
  current_protection_threshold_ma_ = 0;
}
inline float LddStatus::_internal_current_protection_threshold_ma() const {
  return current_protection_threshold_ma_;
}
inline float LddStatus::current_protection_threshold_ma() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_protection_threshold_ma)
  return _internal_current_protection_threshold_ma();
}
inline void LddStatus::_internal_set_current_protection_threshold_ma(float value) {
  
  current_protection_threshold_ma_ = value;
}
inline void LddStatus::set_current_protection_threshold_ma(float value) {
  _internal_set_current_protection_threshold_ma(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_protection_threshold_ma)
}

// float current_calibration_percent = 13;
inline void LddStatus::clear_current_calibration_percent() {
  current_calibration_percent_ = 0;
}
inline float LddStatus::_internal_current_calibration_percent() const {
  return current_calibration_percent_;
}
inline float LddStatus::current_calibration_percent() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.current_calibration_percent)
  return _internal_current_calibration_percent();
}
inline void LddStatus::_internal_set_current_calibration_percent(float value) {
  
  current_calibration_percent_ = value;
}
inline void LddStatus::set_current_calibration_percent(float value) {
  _internal_set_current_calibration_percent(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.current_calibration_percent)
}

// float measured_voltage_v = 14;
inline void LddStatus::clear_measured_voltage_v() {
  measured_voltage_v_ = 0;
}
inline float LddStatus::_internal_measured_voltage_v() const {
  return measured_voltage_v_;
}
inline float LddStatus::measured_voltage_v() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LddStatus.measured_voltage_v)
  return _internal_measured_voltage_v();
}
inline void LddStatus::_internal_set_measured_voltage_v(float value) {
  
  measured_voltage_v_ = value;
}
inline void LddStatus::set_measured_voltage_v(float value) {
  _internal_set_measured_voltage_v(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LddStatus.measured_voltage_v)
}

// -------------------------------------------------------------------

// TecStatus

// float temperature_celsius = 1;
inline void TecStatus::clear_temperature_celsius() {
  temperature_celsius_ = 0;
}
inline float TecStatus::_internal_temperature_celsius() const {
  return temperature_celsius_;
}
inline float TecStatus::temperature_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.temperature_celsius)
  return _internal_temperature_celsius();
}
inline void TecStatus::_internal_set_temperature_celsius(float value) {
  
  temperature_celsius_ = value;
}
inline void TecStatus::set_temperature_celsius(float value) {
  _internal_set_temperature_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.temperature_celsius)
}

// float temp_max_celsius = 2;
inline void TecStatus::clear_temp_max_celsius() {
  temp_max_celsius_ = 0;
}
inline float TecStatus::_internal_temp_max_celsius() const {
  return temp_max_celsius_;
}
inline float TecStatus::temp_max_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.temp_max_celsius)
  return _internal_temp_max_celsius();
}
inline void TecStatus::_internal_set_temp_max_celsius(float value) {
  
  temp_max_celsius_ = value;
}
inline void TecStatus::set_temp_max_celsius(float value) {
  _internal_set_temp_max_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.temp_max_celsius)
}

// float temp_min_celsius = 3;
inline void TecStatus::clear_temp_min_celsius() {
  temp_min_celsius_ = 0;
}
inline float TecStatus::_internal_temp_min_celsius() const {
  return temp_min_celsius_;
}
inline float TecStatus::temp_min_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.temp_min_celsius)
  return _internal_temp_min_celsius();
}
inline void TecStatus::_internal_set_temp_min_celsius(float value) {
  
  temp_min_celsius_ = value;
}
inline void TecStatus::set_temp_min_celsius(float value) {
  _internal_set_temp_min_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.temp_min_celsius)
}

// float temp_max_limit_celsius = 4;
inline void TecStatus::clear_temp_max_limit_celsius() {
  temp_max_limit_celsius_ = 0;
}
inline float TecStatus::_internal_temp_max_limit_celsius() const {
  return temp_max_limit_celsius_;
}
inline float TecStatus::temp_max_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.temp_max_limit_celsius)
  return _internal_temp_max_limit_celsius();
}
inline void TecStatus::_internal_set_temp_max_limit_celsius(float value) {
  
  temp_max_limit_celsius_ = value;
}
inline void TecStatus::set_temp_max_limit_celsius(float value) {
  _internal_set_temp_max_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.temp_max_limit_celsius)
}

// float temp_min_limit_celsius = 5;
inline void TecStatus::clear_temp_min_limit_celsius() {
  temp_min_limit_celsius_ = 0;
}
inline float TecStatus::_internal_temp_min_limit_celsius() const {
  return temp_min_limit_celsius_;
}
inline float TecStatus::temp_min_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.temp_min_limit_celsius)
  return _internal_temp_min_limit_celsius();
}
inline void TecStatus::_internal_set_temp_min_limit_celsius(float value) {
  
  temp_min_limit_celsius_ = value;
}
inline void TecStatus::set_temp_min_limit_celsius(float value) {
  _internal_set_temp_min_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.temp_min_limit_celsius)
}

// float measured_temperature_celsius = 6;
inline void TecStatus::clear_measured_temperature_celsius() {
  measured_temperature_celsius_ = 0;
}
inline float TecStatus::_internal_measured_temperature_celsius() const {
  return measured_temperature_celsius_;
}
inline float TecStatus::measured_temperature_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.measured_temperature_celsius)
  return _internal_measured_temperature_celsius();
}
inline void TecStatus::_internal_set_measured_temperature_celsius(float value) {
  
  measured_temperature_celsius_ = value;
}
inline void TecStatus::set_measured_temperature_celsius(float value) {
  _internal_set_measured_temperature_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.measured_temperature_celsius)
}

// float measured_current_a = 7;
inline void TecStatus::clear_measured_current_a() {
  measured_current_a_ = 0;
}
inline float TecStatus::_internal_measured_current_a() const {
  return measured_current_a_;
}
inline float TecStatus::measured_current_a() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.measured_current_a)
  return _internal_measured_current_a();
}
inline void TecStatus::_internal_set_measured_current_a(float value) {
  
  measured_current_a_ = value;
}
inline void TecStatus::set_measured_current_a(float value) {
  _internal_set_measured_current_a(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.measured_current_a)
}

// float current_limit_a = 8;
inline void TecStatus::clear_current_limit_a() {
  current_limit_a_ = 0;
}
inline float TecStatus::_internal_current_limit_a() const {
  return current_limit_a_;
}
inline float TecStatus::current_limit_a() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.current_limit_a)
  return _internal_current_limit_a();
}
inline void TecStatus::_internal_set_current_limit_a(float value) {
  
  current_limit_a_ = value;
}
inline void TecStatus::set_current_limit_a(float value) {
  _internal_set_current_limit_a(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.current_limit_a)
}

// float measured_voltage_v = 9;
inline void TecStatus::clear_measured_voltage_v() {
  measured_voltage_v_ = 0;
}
inline float TecStatus::_internal_measured_voltage_v() const {
  return measured_voltage_v_;
}
inline float TecStatus::measured_voltage_v() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.measured_voltage_v)
  return _internal_measured_voltage_v();
}
inline void TecStatus::_internal_set_measured_voltage_v(float value) {
  
  measured_voltage_v_ = value;
}
inline void TecStatus::set_measured_voltage_v(float value) {
  _internal_set_measured_voltage_v(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.measured_voltage_v)
}

// float calibration_percent = 10;
inline void TecStatus::clear_calibration_percent() {
  calibration_percent_ = 0;
}
inline float TecStatus::_internal_calibration_percent() const {
  return calibration_percent_;
}
inline float TecStatus::calibration_percent() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.calibration_percent)
  return _internal_calibration_percent();
}
inline void TecStatus::_internal_set_calibration_percent(float value) {
  
  calibration_percent_ = value;
}
inline void TecStatus::set_calibration_percent(float value) {
  _internal_set_calibration_percent(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.calibration_percent)
}

// uint32 p_coefficient = 11;
inline void TecStatus::clear_p_coefficient() {
  p_coefficient_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::_internal_p_coefficient() const {
  return p_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::p_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.p_coefficient)
  return _internal_p_coefficient();
}
inline void TecStatus::_internal_set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  p_coefficient_ = value;
}
inline void TecStatus::set_p_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_p_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.p_coefficient)
}

// uint32 i_coefficient = 12;
inline void TecStatus::clear_i_coefficient() {
  i_coefficient_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::_internal_i_coefficient() const {
  return i_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::i_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.i_coefficient)
  return _internal_i_coefficient();
}
inline void TecStatus::_internal_set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  i_coefficient_ = value;
}
inline void TecStatus::set_i_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_i_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.i_coefficient)
}

// uint32 d_coefficient = 13;
inline void TecStatus::clear_d_coefficient() {
  d_coefficient_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::_internal_d_coefficient() const {
  return d_coefficient_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TecStatus::d_coefficient() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.d_coefficient)
  return _internal_d_coefficient();
}
inline void TecStatus::_internal_set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  d_coefficient_ = value;
}
inline void TecStatus::set_d_coefficient(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_d_coefficient(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.d_coefficient)
}

// float external_ntc_lower_limit_celsius = 14;
inline void TecStatus::clear_external_ntc_lower_limit_celsius() {
  external_ntc_lower_limit_celsius_ = 0;
}
inline float TecStatus::_internal_external_ntc_lower_limit_celsius() const {
  return external_ntc_lower_limit_celsius_;
}
inline float TecStatus::external_ntc_lower_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.external_ntc_lower_limit_celsius)
  return _internal_external_ntc_lower_limit_celsius();
}
inline void TecStatus::_internal_set_external_ntc_lower_limit_celsius(float value) {
  
  external_ntc_lower_limit_celsius_ = value;
}
inline void TecStatus::set_external_ntc_lower_limit_celsius(float value) {
  _internal_set_external_ntc_lower_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.external_ntc_lower_limit_celsius)
}

// float external_ntc_upper_limit_celsius = 15;
inline void TecStatus::clear_external_ntc_upper_limit_celsius() {
  external_ntc_upper_limit_celsius_ = 0;
}
inline float TecStatus::_internal_external_ntc_upper_limit_celsius() const {
  return external_ntc_upper_limit_celsius_;
}
inline float TecStatus::external_ntc_upper_limit_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.external_ntc_upper_limit_celsius)
  return _internal_external_ntc_upper_limit_celsius();
}
inline void TecStatus::_internal_set_external_ntc_upper_limit_celsius(float value) {
  
  external_ntc_upper_limit_celsius_ = value;
}
inline void TecStatus::set_external_ntc_upper_limit_celsius(float value) {
  _internal_set_external_ntc_upper_limit_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.external_ntc_upper_limit_celsius)
}

// float external_ntc_measured_temp_celsius = 16;
inline void TecStatus::clear_external_ntc_measured_temp_celsius() {
  external_ntc_measured_temp_celsius_ = 0;
}
inline float TecStatus::_internal_external_ntc_measured_temp_celsius() const {
  return external_ntc_measured_temp_celsius_;
}
inline float TecStatus::external_ntc_measured_temp_celsius() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStatus.external_ntc_measured_temp_celsius)
  return _internal_external_ntc_measured_temp_celsius();
}
inline void TecStatus::_internal_set_external_ntc_measured_temp_celsius(float value) {
  
  external_ntc_measured_temp_celsius_ = value;
}
inline void TecStatus::set_external_ntc_measured_temp_celsius(float value) {
  _internal_set_external_ntc_measured_temp_celsius(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStatus.external_ntc_measured_temp_celsius)
}

// -------------------------------------------------------------------

// DriverStateInfo

// bool is_powered_on = 1;
inline void DriverStateInfo::clear_is_powered_on() {
  is_powered_on_ = false;
}
inline bool DriverStateInfo::_internal_is_powered_on() const {
  return is_powered_on_;
}
inline bool DriverStateInfo::is_powered_on() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.is_powered_on)
  return _internal_is_powered_on();
}
inline void DriverStateInfo::_internal_set_is_powered_on(bool value) {
  
  is_powered_on_ = value;
}
inline void DriverStateInfo::set_is_powered_on(bool value) {
  _internal_set_is_powered_on(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.is_powered_on)
}

// bool is_started = 2;
inline void DriverStateInfo::clear_is_started() {
  is_started_ = false;
}
inline bool DriverStateInfo::_internal_is_started() const {
  return is_started_;
}
inline bool DriverStateInfo::is_started() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.is_started)
  return _internal_is_started();
}
inline void DriverStateInfo::_internal_set_is_started(bool value) {
  
  is_started_ = value;
}
inline void DriverStateInfo::set_is_started(bool value) {
  _internal_set_is_started(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.is_started)
}

// bool current_set_is_internal = 3;
inline void DriverStateInfo::clear_current_set_is_internal() {
  current_set_is_internal_ = false;
}
inline bool DriverStateInfo::_internal_current_set_is_internal() const {
  return current_set_is_internal_;
}
inline bool DriverStateInfo::current_set_is_internal() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.current_set_is_internal)
  return _internal_current_set_is_internal();
}
inline void DriverStateInfo::_internal_set_current_set_is_internal(bool value) {
  
  current_set_is_internal_ = value;
}
inline void DriverStateInfo::set_current_set_is_internal(bool value) {
  _internal_set_current_set_is_internal(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.current_set_is_internal)
}

// bool enable_is_internal = 4;
inline void DriverStateInfo::clear_enable_is_internal() {
  enable_is_internal_ = false;
}
inline bool DriverStateInfo::_internal_enable_is_internal() const {
  return enable_is_internal_;
}
inline bool DriverStateInfo::enable_is_internal() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.enable_is_internal)
  return _internal_enable_is_internal();
}
inline void DriverStateInfo::_internal_set_enable_is_internal(bool value) {
  
  enable_is_internal_ = value;
}
inline void DriverStateInfo::set_enable_is_internal(bool value) {
  _internal_set_enable_is_internal(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.enable_is_internal)
}

// bool ext_ntc_interlock_is_denied = 5;
inline void DriverStateInfo::clear_ext_ntc_interlock_is_denied() {
  ext_ntc_interlock_is_denied_ = false;
}
inline bool DriverStateInfo::_internal_ext_ntc_interlock_is_denied() const {
  return ext_ntc_interlock_is_denied_;
}
inline bool DriverStateInfo::ext_ntc_interlock_is_denied() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.ext_ntc_interlock_is_denied)
  return _internal_ext_ntc_interlock_is_denied();
}
inline void DriverStateInfo::_internal_set_ext_ntc_interlock_is_denied(bool value) {
  
  ext_ntc_interlock_is_denied_ = value;
}
inline void DriverStateInfo::set_ext_ntc_interlock_is_denied(bool value) {
  _internal_set_ext_ntc_interlock_is_denied(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.ext_ntc_interlock_is_denied)
}

// bool interlock_is_denied = 6;
inline void DriverStateInfo::clear_interlock_is_denied() {
  interlock_is_denied_ = false;
}
inline bool DriverStateInfo::_internal_interlock_is_denied() const {
  return interlock_is_denied_;
}
inline bool DriverStateInfo::interlock_is_denied() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.DriverStateInfo.interlock_is_denied)
  return _internal_interlock_is_denied();
}
inline void DriverStateInfo::_internal_set_interlock_is_denied(bool value) {
  
  interlock_is_denied_ = value;
}
inline void DriverStateInfo::set_interlock_is_denied(bool value) {
  _internal_set_interlock_is_denied(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.DriverStateInfo.interlock_is_denied)
}

// -------------------------------------------------------------------

// TecStateInfo

// bool is_started = 1;
inline void TecStateInfo::clear_is_started() {
  is_started_ = false;
}
inline bool TecStateInfo::_internal_is_started() const {
  return is_started_;
}
inline bool TecStateInfo::is_started() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStateInfo.is_started)
  return _internal_is_started();
}
inline void TecStateInfo::_internal_set_is_started(bool value) {
  
  is_started_ = value;
}
inline void TecStateInfo::set_is_started(bool value) {
  _internal_set_is_started(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStateInfo.is_started)
}

// bool temp_set_is_internal = 2;
inline void TecStateInfo::clear_temp_set_is_internal() {
  temp_set_is_internal_ = false;
}
inline bool TecStateInfo::_internal_temp_set_is_internal() const {
  return temp_set_is_internal_;
}
inline bool TecStateInfo::temp_set_is_internal() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStateInfo.temp_set_is_internal)
  return _internal_temp_set_is_internal();
}
inline void TecStateInfo::_internal_set_temp_set_is_internal(bool value) {
  
  temp_set_is_internal_ = value;
}
inline void TecStateInfo::set_temp_set_is_internal(bool value) {
  _internal_set_temp_set_is_internal(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStateInfo.temp_set_is_internal)
}

// bool enable_is_internal = 3;
inline void TecStateInfo::clear_enable_is_internal() {
  enable_is_internal_ = false;
}
inline bool TecStateInfo::_internal_enable_is_internal() const {
  return enable_is_internal_;
}
inline bool TecStateInfo::enable_is_internal() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.TecStateInfo.enable_is_internal)
  return _internal_enable_is_internal();
}
inline void TecStateInfo::_internal_set_enable_is_internal(bool value) {
  
  enable_is_internal_ = value;
}
inline void TecStateInfo::set_enable_is_internal(bool value) {
  _internal_set_enable_is_internal(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.TecStateInfo.enable_is_internal)
}

// -------------------------------------------------------------------

// LockStatusInfo

// bool interlock_active = 1;
inline void LockStatusInfo::clear_interlock_active() {
  interlock_active_ = false;
}
inline bool LockStatusInfo::_internal_interlock_active() const {
  return interlock_active_;
}
inline bool LockStatusInfo::interlock_active() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.interlock_active)
  return _internal_interlock_active();
}
inline void LockStatusInfo::_internal_set_interlock_active(bool value) {
  
  interlock_active_ = value;
}
inline void LockStatusInfo::set_interlock_active(bool value) {
  _internal_set_interlock_active(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.interlock_active)
}

// bool ld_over_current = 2;
inline void LockStatusInfo::clear_ld_over_current() {
  ld_over_current_ = false;
}
inline bool LockStatusInfo::_internal_ld_over_current() const {
  return ld_over_current_;
}
inline bool LockStatusInfo::ld_over_current() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.ld_over_current)
  return _internal_ld_over_current();
}
inline void LockStatusInfo::_internal_set_ld_over_current(bool value) {
  
  ld_over_current_ = value;
}
inline void LockStatusInfo::set_ld_over_current(bool value) {
  _internal_set_ld_over_current(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.ld_over_current)
}

// bool ld_overheat = 3;
inline void LockStatusInfo::clear_ld_overheat() {
  ld_overheat_ = false;
}
inline bool LockStatusInfo::_internal_ld_overheat() const {
  return ld_overheat_;
}
inline bool LockStatusInfo::ld_overheat() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.ld_overheat)
  return _internal_ld_overheat();
}
inline void LockStatusInfo::_internal_set_ld_overheat(bool value) {
  
  ld_overheat_ = value;
}
inline void LockStatusInfo::set_ld_overheat(bool value) {
  _internal_set_ld_overheat(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.ld_overheat)
}

// bool ext_ntc_interlock_active = 4;
inline void LockStatusInfo::clear_ext_ntc_interlock_active() {
  ext_ntc_interlock_active_ = false;
}
inline bool LockStatusInfo::_internal_ext_ntc_interlock_active() const {
  return ext_ntc_interlock_active_;
}
inline bool LockStatusInfo::ext_ntc_interlock_active() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.ext_ntc_interlock_active)
  return _internal_ext_ntc_interlock_active();
}
inline void LockStatusInfo::_internal_set_ext_ntc_interlock_active(bool value) {
  
  ext_ntc_interlock_active_ = value;
}
inline void LockStatusInfo::set_ext_ntc_interlock_active(bool value) {
  _internal_set_ext_ntc_interlock_active(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.ext_ntc_interlock_active)
}

// bool tec_error = 5;
inline void LockStatusInfo::clear_tec_error() {
  tec_error_ = false;
}
inline bool LockStatusInfo::_internal_tec_error() const {
  return tec_error_;
}
inline bool LockStatusInfo::tec_error() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.tec_error)
  return _internal_tec_error();
}
inline void LockStatusInfo::_internal_set_tec_error(bool value) {
  
  tec_error_ = value;
}
inline void LockStatusInfo::set_tec_error(bool value) {
  _internal_set_tec_error(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.tec_error)
}

// bool tec_self_heat = 6;
inline void LockStatusInfo::clear_tec_self_heat() {
  tec_self_heat_ = false;
}
inline bool LockStatusInfo::_internal_tec_self_heat() const {
  return tec_self_heat_;
}
inline bool LockStatusInfo::tec_self_heat() const {
  // @@protoc_insertion_point(field_get:sf8xxx_nm.LockStatusInfo.tec_self_heat)
  return _internal_tec_self_heat();
}
inline void LockStatusInfo::_internal_set_tec_self_heat(bool value) {
  
  tec_self_heat_ = value;
}
inline void LockStatusInfo::set_tec_self_heat(bool value) {
  _internal_set_tec_self_heat(value);
  // @@protoc_insertion_point(field_set:sf8xxx_nm.LockStatusInfo.tec_self_heat)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sf8xxx_nm

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sf8xxx_nm::DriverStateSettings_CurrentSetSource> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::DriverStateSettings_EnableSource> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::DriverStateSettings_InterlockPolicy> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::TecStateSettings_TempSetSource> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::TecStateSettings_EnableSource> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::RequestType> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::ActionType> : ::std::true_type {};
template <> struct is_proto_enum< ::sf8xxx_nm::ErrorCode> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sf8xxx_5fnm_2eproto
