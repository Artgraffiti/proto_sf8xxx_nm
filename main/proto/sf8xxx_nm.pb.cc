// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sf8xxx_nm.proto

#include "sf8xxx_nm.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace sf8xxx_nm {
constexpr DriverCommand::DriverCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct DriverCommandDefaultTypeInternal {
  constexpr DriverCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DriverCommandDefaultTypeInternal() {}
  union {
    DriverCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DriverCommandDefaultTypeInternal _DriverCommand_default_instance_;
constexpr DriverResponse::DriverResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ldd_status_(nullptr)
  , tec_status_(nullptr)
  , driver_state_(nullptr)
  , tec_state_(nullptr)
  , lock_status_(nullptr)
  , error_code_(0)

  , serial_number_(0u){}
struct DriverResponseDefaultTypeInternal {
  constexpr DriverResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DriverResponseDefaultTypeInternal() {}
  union {
    DriverResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DriverResponseDefaultTypeInternal _DriverResponse_default_instance_;
constexpr ConfigureCommand::ConfigureCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ldd_settings_(nullptr)
  , tec_settings_(nullptr)
  , pid_settings_(nullptr)
  , ntc_interlock_settings_(nullptr)
  , driver_state_settings_(nullptr)
  , tec_state_settings_(nullptr){}
struct ConfigureCommandDefaultTypeInternal {
  constexpr ConfigureCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigureCommandDefaultTypeInternal() {}
  union {
    ConfigureCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigureCommandDefaultTypeInternal _ConfigureCommand_default_instance_;
constexpr LddSettings::LddSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frequency_hz_(0)
  , duration_ms_(0)
  , current_ma_(0)
  , current_max_ma_(0)
  , current_calibration_percent_(0){}
struct LddSettingsDefaultTypeInternal {
  constexpr LddSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LddSettingsDefaultTypeInternal() {}
  union {
    LddSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LddSettingsDefaultTypeInternal _LddSettings_default_instance_;
constexpr TecSettings::TecSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : temperature_celsius_(0)
  , temp_max_celsius_(0)
  , temp_min_celsius_(0)
  , current_limit_a_(0)
  , calibration_percent_(0)
  , internal_ntc_b_coefficient_(0u){}
struct TecSettingsDefaultTypeInternal {
  constexpr TecSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TecSettingsDefaultTypeInternal() {}
  union {
    TecSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TecSettingsDefaultTypeInternal _TecSettings_default_instance_;
constexpr PidSettings::PidSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : p_coefficient_(0u)
  , i_coefficient_(0u)
  , d_coefficient_(0u){}
struct PidSettingsDefaultTypeInternal {
  constexpr PidSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PidSettingsDefaultTypeInternal() {}
  union {
    PidSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PidSettingsDefaultTypeInternal _PidSettings_default_instance_;
constexpr NtcInterlockSettings::NtcInterlockSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : lower_limit_celsius_(0)
  , upper_limit_celsius_(0)
  , b_coefficient_(0u){}
struct NtcInterlockSettingsDefaultTypeInternal {
  constexpr NtcInterlockSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~NtcInterlockSettingsDefaultTypeInternal() {}
  union {
    NtcInterlockSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT NtcInterlockSettingsDefaultTypeInternal _NtcInterlockSettings_default_instance_;
constexpr DriverStateSettings::DriverStateSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : current_set_source_(0)

  , enable_source_(0)

  , interlock_policy_(0)

  , ntc_interlock_policy_(0)
{}
struct DriverStateSettingsDefaultTypeInternal {
  constexpr DriverStateSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DriverStateSettingsDefaultTypeInternal() {}
  union {
    DriverStateSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DriverStateSettingsDefaultTypeInternal _DriverStateSettings_default_instance_;
constexpr TecStateSettings::TecStateSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : temp_set_source_(0)

  , enable_source_(0)
{}
struct TecStateSettingsDefaultTypeInternal {
  constexpr TecStateSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TecStateSettingsDefaultTypeInternal() {}
  union {
    TecStateSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TecStateSettingsDefaultTypeInternal _TecStateSettings_default_instance_;
constexpr RequestCommand::RequestCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : requests_()
  , _requests_cached_byte_size_(){}
struct RequestCommandDefaultTypeInternal {
  constexpr RequestCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RequestCommandDefaultTypeInternal() {}
  union {
    RequestCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RequestCommandDefaultTypeInternal _RequestCommand_default_instance_;
constexpr ActionCommand::ActionCommand(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)
{}
struct ActionCommandDefaultTypeInternal {
  constexpr ActionCommandDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ActionCommandDefaultTypeInternal() {}
  union {
    ActionCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ActionCommandDefaultTypeInternal _ActionCommand_default_instance_;
constexpr LddStatus::LddStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frequency_hz_(0)
  , frequency_min_hz_(0)
  , frequency_max_hz_(0)
  , duration_ms_(0)
  , duration_min_ms_(0)
  , duration_max_ms_(0)
  , current_ma_(0)
  , current_min_ma_(0)
  , current_max_ma_(0)
  , current_max_limit_ma_(0)
  , measured_current_ma_(0)
  , current_protection_threshold_ma_(0)
  , current_calibration_percent_(0)
  , measured_voltage_v_(0){}
struct LddStatusDefaultTypeInternal {
  constexpr LddStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LddStatusDefaultTypeInternal() {}
  union {
    LddStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LddStatusDefaultTypeInternal _LddStatus_default_instance_;
constexpr TecStatus::TecStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : temperature_celsius_(0)
  , temp_max_celsius_(0)
  , temp_min_celsius_(0)
  , temp_max_limit_celsius_(0)
  , temp_min_limit_celsius_(0)
  , measured_temperature_celsius_(0)
  , measured_current_a_(0)
  , current_limit_a_(0)
  , measured_voltage_v_(0)
  , calibration_percent_(0)
  , p_coefficient_(0u)
  , i_coefficient_(0u)
  , d_coefficient_(0u)
  , external_ntc_lower_limit_celsius_(0)
  , external_ntc_upper_limit_celsius_(0)
  , external_ntc_measured_temp_celsius_(0){}
struct TecStatusDefaultTypeInternal {
  constexpr TecStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TecStatusDefaultTypeInternal() {}
  union {
    TecStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TecStatusDefaultTypeInternal _TecStatus_default_instance_;
constexpr DriverStateInfo::DriverStateInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : is_powered_on_(false)
  , is_started_(false)
  , current_set_is_internal_(false)
  , enable_is_internal_(false)
  , ext_ntc_interlock_is_denied_(false)
  , interlock_is_denied_(false){}
struct DriverStateInfoDefaultTypeInternal {
  constexpr DriverStateInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DriverStateInfoDefaultTypeInternal() {}
  union {
    DriverStateInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DriverStateInfoDefaultTypeInternal _DriverStateInfo_default_instance_;
constexpr TecStateInfo::TecStateInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : is_started_(false)
  , temp_set_is_internal_(false)
  , enable_is_internal_(false){}
struct TecStateInfoDefaultTypeInternal {
  constexpr TecStateInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TecStateInfoDefaultTypeInternal() {}
  union {
    TecStateInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TecStateInfoDefaultTypeInternal _TecStateInfo_default_instance_;
constexpr LockStatusInfo::LockStatusInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : interlock_active_(false)
  , ld_over_current_(false)
  , ld_overheat_(false)
  , ext_ntc_interlock_active_(false)
  , tec_error_(false)
  , tec_self_heat_(false){}
struct LockStatusInfoDefaultTypeInternal {
  constexpr LockStatusInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LockStatusInfoDefaultTypeInternal() {}
  union {
    LockStatusInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LockStatusInfoDefaultTypeInternal _LockStatusInfo_default_instance_;
}  // namespace sf8xxx_nm
namespace sf8xxx_nm {
bool DriverStateSettings_CurrentSetSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DriverStateSettings_CurrentSetSource_strings[3] = {};

static const char DriverStateSettings_CurrentSetSource_names[] =
  "CURRENT_SET_SOURCE_UNSPECIFIED"
  "EXTERNAL"
  "INTERNAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DriverStateSettings_CurrentSetSource_entries[] = {
  { {DriverStateSettings_CurrentSetSource_names + 0, 30}, 0 },
  { {DriverStateSettings_CurrentSetSource_names + 30, 8}, 1 },
  { {DriverStateSettings_CurrentSetSource_names + 38, 8}, 2 },
};

static const int DriverStateSettings_CurrentSetSource_entries_by_number[] = {
  0, // 0 -> CURRENT_SET_SOURCE_UNSPECIFIED
  1, // 1 -> EXTERNAL
  2, // 2 -> INTERNAL
};

const std::string& DriverStateSettings_CurrentSetSource_Name(
    DriverStateSettings_CurrentSetSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DriverStateSettings_CurrentSetSource_entries,
          DriverStateSettings_CurrentSetSource_entries_by_number,
          3, DriverStateSettings_CurrentSetSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DriverStateSettings_CurrentSetSource_entries,
      DriverStateSettings_CurrentSetSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DriverStateSettings_CurrentSetSource_strings[idx].get();
}
bool DriverStateSettings_CurrentSetSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_CurrentSetSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DriverStateSettings_CurrentSetSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DriverStateSettings_CurrentSetSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings::CURRENT_SET_SOURCE_UNSPECIFIED;
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings::EXTERNAL;
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings::INTERNAL;
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings::CurrentSetSource_MIN;
constexpr DriverStateSettings_CurrentSetSource DriverStateSettings::CurrentSetSource_MAX;
constexpr int DriverStateSettings::CurrentSetSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool DriverStateSettings_EnableSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DriverStateSettings_EnableSource_strings[3] = {};

static const char DriverStateSettings_EnableSource_names[] =
  "ENABLE_SOURCE_UNSPECIFIED"
  "EXTERNAL_PIN"
  "INTERNAL_CMD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DriverStateSettings_EnableSource_entries[] = {
  { {DriverStateSettings_EnableSource_names + 0, 25}, 0 },
  { {DriverStateSettings_EnableSource_names + 25, 12}, 1 },
  { {DriverStateSettings_EnableSource_names + 37, 12}, 2 },
};

static const int DriverStateSettings_EnableSource_entries_by_number[] = {
  0, // 0 -> ENABLE_SOURCE_UNSPECIFIED
  1, // 1 -> EXTERNAL_PIN
  2, // 2 -> INTERNAL_CMD
};

const std::string& DriverStateSettings_EnableSource_Name(
    DriverStateSettings_EnableSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DriverStateSettings_EnableSource_entries,
          DriverStateSettings_EnableSource_entries_by_number,
          3, DriverStateSettings_EnableSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DriverStateSettings_EnableSource_entries,
      DriverStateSettings_EnableSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DriverStateSettings_EnableSource_strings[idx].get();
}
bool DriverStateSettings_EnableSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_EnableSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DriverStateSettings_EnableSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DriverStateSettings_EnableSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DriverStateSettings_EnableSource DriverStateSettings::ENABLE_SOURCE_UNSPECIFIED;
constexpr DriverStateSettings_EnableSource DriverStateSettings::EXTERNAL_PIN;
constexpr DriverStateSettings_EnableSource DriverStateSettings::INTERNAL_CMD;
constexpr DriverStateSettings_EnableSource DriverStateSettings::EnableSource_MIN;
constexpr DriverStateSettings_EnableSource DriverStateSettings::EnableSource_MAX;
constexpr int DriverStateSettings::EnableSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool DriverStateSettings_InterlockPolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DriverStateSettings_InterlockPolicy_strings[3] = {};

static const char DriverStateSettings_InterlockPolicy_names[] =
  "ALLOW"
  "DENY"
  "INTERLOCK_POLICY_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DriverStateSettings_InterlockPolicy_entries[] = {
  { {DriverStateSettings_InterlockPolicy_names + 0, 5}, 1 },
  { {DriverStateSettings_InterlockPolicy_names + 5, 4}, 2 },
  { {DriverStateSettings_InterlockPolicy_names + 9, 28}, 0 },
};

static const int DriverStateSettings_InterlockPolicy_entries_by_number[] = {
  2, // 0 -> INTERLOCK_POLICY_UNSPECIFIED
  0, // 1 -> ALLOW
  1, // 2 -> DENY
};

const std::string& DriverStateSettings_InterlockPolicy_Name(
    DriverStateSettings_InterlockPolicy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DriverStateSettings_InterlockPolicy_entries,
          DriverStateSettings_InterlockPolicy_entries_by_number,
          3, DriverStateSettings_InterlockPolicy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DriverStateSettings_InterlockPolicy_entries,
      DriverStateSettings_InterlockPolicy_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DriverStateSettings_InterlockPolicy_strings[idx].get();
}
bool DriverStateSettings_InterlockPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_InterlockPolicy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DriverStateSettings_InterlockPolicy_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DriverStateSettings_InterlockPolicy>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings::INTERLOCK_POLICY_UNSPECIFIED;
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings::ALLOW;
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings::DENY;
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings::InterlockPolicy_MIN;
constexpr DriverStateSettings_InterlockPolicy DriverStateSettings::InterlockPolicy_MAX;
constexpr int DriverStateSettings::InterlockPolicy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool DriverStateSettings_NtcInterlockPolicy_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DriverStateSettings_NtcInterlockPolicy_strings[3] = {};

static const char DriverStateSettings_NtcInterlockPolicy_names[] =
  "ALLOW_NTC"
  "DENY_NTC"
  "NTC_INTERLOCK_POLICY_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DriverStateSettings_NtcInterlockPolicy_entries[] = {
  { {DriverStateSettings_NtcInterlockPolicy_names + 0, 9}, 1 },
  { {DriverStateSettings_NtcInterlockPolicy_names + 9, 8}, 2 },
  { {DriverStateSettings_NtcInterlockPolicy_names + 17, 32}, 0 },
};

static const int DriverStateSettings_NtcInterlockPolicy_entries_by_number[] = {
  2, // 0 -> NTC_INTERLOCK_POLICY_UNSPECIFIED
  0, // 1 -> ALLOW_NTC
  1, // 2 -> DENY_NTC
};

const std::string& DriverStateSettings_NtcInterlockPolicy_Name(
    DriverStateSettings_NtcInterlockPolicy value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DriverStateSettings_NtcInterlockPolicy_entries,
          DriverStateSettings_NtcInterlockPolicy_entries_by_number,
          3, DriverStateSettings_NtcInterlockPolicy_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DriverStateSettings_NtcInterlockPolicy_entries,
      DriverStateSettings_NtcInterlockPolicy_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DriverStateSettings_NtcInterlockPolicy_strings[idx].get();
}
bool DriverStateSettings_NtcInterlockPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DriverStateSettings_NtcInterlockPolicy* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DriverStateSettings_NtcInterlockPolicy_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<DriverStateSettings_NtcInterlockPolicy>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings::NTC_INTERLOCK_POLICY_UNSPECIFIED;
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings::ALLOW_NTC;
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings::DENY_NTC;
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings::NtcInterlockPolicy_MIN;
constexpr DriverStateSettings_NtcInterlockPolicy DriverStateSettings::NtcInterlockPolicy_MAX;
constexpr int DriverStateSettings::NtcInterlockPolicy_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TecStateSettings_TempSetSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TecStateSettings_TempSetSource_strings[3] = {};

static const char TecStateSettings_TempSetSource_names[] =
  "EXTERNAL"
  "INTERNAL"
  "TEMP_SET_SOURCE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TecStateSettings_TempSetSource_entries[] = {
  { {TecStateSettings_TempSetSource_names + 0, 8}, 1 },
  { {TecStateSettings_TempSetSource_names + 8, 8}, 2 },
  { {TecStateSettings_TempSetSource_names + 16, 27}, 0 },
};

static const int TecStateSettings_TempSetSource_entries_by_number[] = {
  2, // 0 -> TEMP_SET_SOURCE_UNSPECIFIED
  0, // 1 -> EXTERNAL
  1, // 2 -> INTERNAL
};

const std::string& TecStateSettings_TempSetSource_Name(
    TecStateSettings_TempSetSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TecStateSettings_TempSetSource_entries,
          TecStateSettings_TempSetSource_entries_by_number,
          3, TecStateSettings_TempSetSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TecStateSettings_TempSetSource_entries,
      TecStateSettings_TempSetSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TecStateSettings_TempSetSource_strings[idx].get();
}
bool TecStateSettings_TempSetSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TecStateSettings_TempSetSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TecStateSettings_TempSetSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TecStateSettings_TempSetSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TecStateSettings_TempSetSource TecStateSettings::TEMP_SET_SOURCE_UNSPECIFIED;
constexpr TecStateSettings_TempSetSource TecStateSettings::EXTERNAL;
constexpr TecStateSettings_TempSetSource TecStateSettings::INTERNAL;
constexpr TecStateSettings_TempSetSource TecStateSettings::TempSetSource_MIN;
constexpr TecStateSettings_TempSetSource TecStateSettings::TempSetSource_MAX;
constexpr int TecStateSettings::TempSetSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool TecStateSettings_EnableSource_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TecStateSettings_EnableSource_strings[3] = {};

static const char TecStateSettings_EnableSource_names[] =
  "ENABLE_SOURCE_UNSPECIFIED"
  "EXTERNAL_PIN"
  "INTERNAL_CMD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TecStateSettings_EnableSource_entries[] = {
  { {TecStateSettings_EnableSource_names + 0, 25}, 0 },
  { {TecStateSettings_EnableSource_names + 25, 12}, 1 },
  { {TecStateSettings_EnableSource_names + 37, 12}, 2 },
};

static const int TecStateSettings_EnableSource_entries_by_number[] = {
  0, // 0 -> ENABLE_SOURCE_UNSPECIFIED
  1, // 1 -> EXTERNAL_PIN
  2, // 2 -> INTERNAL_CMD
};

const std::string& TecStateSettings_EnableSource_Name(
    TecStateSettings_EnableSource value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TecStateSettings_EnableSource_entries,
          TecStateSettings_EnableSource_entries_by_number,
          3, TecStateSettings_EnableSource_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TecStateSettings_EnableSource_entries,
      TecStateSettings_EnableSource_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TecStateSettings_EnableSource_strings[idx].get();
}
bool TecStateSettings_EnableSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TecStateSettings_EnableSource* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TecStateSettings_EnableSource_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<TecStateSettings_EnableSource>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TecStateSettings_EnableSource TecStateSettings::ENABLE_SOURCE_UNSPECIFIED;
constexpr TecStateSettings_EnableSource TecStateSettings::EXTERNAL_PIN;
constexpr TecStateSettings_EnableSource TecStateSettings::INTERNAL_CMD;
constexpr TecStateSettings_EnableSource TecStateSettings::EnableSource_MIN;
constexpr TecStateSettings_EnableSource TecStateSettings::EnableSource_MAX;
constexpr int TecStateSettings::EnableSource_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool RequestType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 40:
    case 50:
    case 51:
    case 52:
    case 53:
    case 60:
    case 61:
    case 62:
    case 63:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RequestType_strings[36] = {};

static const char RequestType_names[] =
  "REQ_CURRENT_CALIBRATION_PERCENT"
  "REQ_CURRENT_MA"
  "REQ_CURRENT_MAX_LIMIT_MA"
  "REQ_CURRENT_MAX_MA"
  "REQ_CURRENT_MIN_MA"
  "REQ_CURRENT_PROTECTION_THRESHOLD_MA"
  "REQ_DRIVER_STATE"
  "REQ_DURATION_MAX_MS"
  "REQ_DURATION_MIN_MS"
  "REQ_DURATION_MS"
  "REQ_EXTERNAL_NTC_ALL"
  "REQ_EXTERNAL_NTC_LOWER_LIMIT_CELSIUS"
  "REQ_EXTERNAL_NTC_MEASURED_TEMP_CELSIUS"
  "REQ_EXTERNAL_NTC_UPPER_LIMIT_CELSIUS"
  "REQ_FREQUENCY_HZ"
  "REQ_FREQUENCY_MAX_HZ"
  "REQ_FREQUENCY_MIN_HZ"
  "REQ_LDD_STATUS_ALL"
  "REQ_LOCK_STATUS"
  "REQ_MEASURED_CURRENT_MA"
  "REQ_MEASURED_VOLTAGE_V"
  "REQ_PID_COEFFICIENTS"
  "REQ_SERIAL_NUMBER"
  "REQ_TEC_CALIBRATION_PERCENT"
  "REQ_TEC_CURRENT_LIMIT_A"
  "REQ_TEC_MEASURED_CURRENT_A"
  "REQ_TEC_MEASURED_TEMPERATURE_CELSIUS"
  "REQ_TEC_MEASURED_VOLTAGE_V"
  "REQ_TEC_STATE"
  "REQ_TEC_STATUS_ALL"
  "REQ_TEC_TEMPERATURE_CELSIUS"
  "REQ_TEC_TEMPERATURE_MAX_CELSIUS"
  "REQ_TEC_TEMPERATURE_MAX_LIMIT_CELSIUS"
  "REQ_TEC_TEMPERATURE_MIN_CELSIUS"
  "REQ_TEC_TEMPERATURE_MIN_LIMIT_CELSIUS"
  "REQ_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RequestType_entries[] = {
  { {RequestType_names + 0, 31}, 14 },
  { {RequestType_names + 31, 14}, 8 },
  { {RequestType_names + 45, 24}, 11 },
  { {RequestType_names + 69, 18}, 10 },
  { {RequestType_names + 87, 18}, 9 },
  { {RequestType_names + 105, 35}, 13 },
  { {RequestType_names + 140, 16}, 60 },
  { {RequestType_names + 156, 19}, 7 },
  { {RequestType_names + 175, 19}, 6 },
  { {RequestType_names + 194, 15}, 5 },
  { {RequestType_names + 209, 20}, 50 },
  { {RequestType_names + 229, 36}, 51 },
  { {RequestType_names + 265, 38}, 53 },
  { {RequestType_names + 303, 36}, 52 },
  { {RequestType_names + 339, 16}, 2 },
  { {RequestType_names + 355, 20}, 4 },
  { {RequestType_names + 375, 20}, 3 },
  { {RequestType_names + 395, 18}, 1 },
  { {RequestType_names + 413, 15}, 62 },
  { {RequestType_names + 428, 23}, 12 },
  { {RequestType_names + 451, 22}, 15 },
  { {RequestType_names + 473, 20}, 40 },
  { {RequestType_names + 493, 17}, 63 },
  { {RequestType_names + 510, 27}, 30 },
  { {RequestType_names + 537, 23}, 28 },
  { {RequestType_names + 560, 26}, 27 },
  { {RequestType_names + 586, 36}, 26 },
  { {RequestType_names + 622, 26}, 29 },
  { {RequestType_names + 648, 13}, 61 },
  { {RequestType_names + 661, 18}, 20 },
  { {RequestType_names + 679, 27}, 21 },
  { {RequestType_names + 706, 31}, 22 },
  { {RequestType_names + 737, 37}, 24 },
  { {RequestType_names + 774, 31}, 23 },
  { {RequestType_names + 805, 37}, 25 },
  { {RequestType_names + 842, 15}, 0 },
};

static const int RequestType_entries_by_number[] = {
  35, // 0 -> REQ_UNSPECIFIED
  17, // 1 -> REQ_LDD_STATUS_ALL
  14, // 2 -> REQ_FREQUENCY_HZ
  16, // 3 -> REQ_FREQUENCY_MIN_HZ
  15, // 4 -> REQ_FREQUENCY_MAX_HZ
  9, // 5 -> REQ_DURATION_MS
  8, // 6 -> REQ_DURATION_MIN_MS
  7, // 7 -> REQ_DURATION_MAX_MS
  1, // 8 -> REQ_CURRENT_MA
  4, // 9 -> REQ_CURRENT_MIN_MA
  3, // 10 -> REQ_CURRENT_MAX_MA
  2, // 11 -> REQ_CURRENT_MAX_LIMIT_MA
  19, // 12 -> REQ_MEASURED_CURRENT_MA
  5, // 13 -> REQ_CURRENT_PROTECTION_THRESHOLD_MA
  0, // 14 -> REQ_CURRENT_CALIBRATION_PERCENT
  20, // 15 -> REQ_MEASURED_VOLTAGE_V
  29, // 20 -> REQ_TEC_STATUS_ALL
  30, // 21 -> REQ_TEC_TEMPERATURE_CELSIUS
  31, // 22 -> REQ_TEC_TEMPERATURE_MAX_CELSIUS
  33, // 23 -> REQ_TEC_TEMPERATURE_MIN_CELSIUS
  32, // 24 -> REQ_TEC_TEMPERATURE_MAX_LIMIT_CELSIUS
  34, // 25 -> REQ_TEC_TEMPERATURE_MIN_LIMIT_CELSIUS
  26, // 26 -> REQ_TEC_MEASURED_TEMPERATURE_CELSIUS
  25, // 27 -> REQ_TEC_MEASURED_CURRENT_A
  24, // 28 -> REQ_TEC_CURRENT_LIMIT_A
  27, // 29 -> REQ_TEC_MEASURED_VOLTAGE_V
  23, // 30 -> REQ_TEC_CALIBRATION_PERCENT
  21, // 40 -> REQ_PID_COEFFICIENTS
  10, // 50 -> REQ_EXTERNAL_NTC_ALL
  11, // 51 -> REQ_EXTERNAL_NTC_LOWER_LIMIT_CELSIUS
  13, // 52 -> REQ_EXTERNAL_NTC_UPPER_LIMIT_CELSIUS
  12, // 53 -> REQ_EXTERNAL_NTC_MEASURED_TEMP_CELSIUS
  6, // 60 -> REQ_DRIVER_STATE
  28, // 61 -> REQ_TEC_STATE
  18, // 62 -> REQ_LOCK_STATUS
  22, // 63 -> REQ_SERIAL_NUMBER
};

const std::string& RequestType_Name(
    RequestType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RequestType_entries,
          RequestType_entries_by_number,
          36, RequestType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RequestType_entries,
      RequestType_entries_by_number,
      36, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RequestType_strings[idx].get();
}
bool RequestType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RequestType_entries, 36, name, &int_value);
  if (success) {
    *value = static_cast<RequestType>(int_value);
  }
  return success;
}
bool ActionType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ActionType_strings[7] = {};

static const char ActionType_names[] =
  "ACTION_UNSPECIFIED"
  "RESET_PARAMETERS"
  "SAVE_PARAMETERS"
  "START_DRIVER"
  "START_TEC"
  "STOP_DRIVER"
  "STOP_TEC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ActionType_entries[] = {
  { {ActionType_names + 0, 18}, 0 },
  { {ActionType_names + 18, 16}, 6 },
  { {ActionType_names + 34, 15}, 5 },
  { {ActionType_names + 49, 12}, 1 },
  { {ActionType_names + 61, 9}, 3 },
  { {ActionType_names + 70, 11}, 2 },
  { {ActionType_names + 81, 8}, 4 },
};

static const int ActionType_entries_by_number[] = {
  0, // 0 -> ACTION_UNSPECIFIED
  3, // 1 -> START_DRIVER
  5, // 2 -> STOP_DRIVER
  4, // 3 -> START_TEC
  6, // 4 -> STOP_TEC
  2, // 5 -> SAVE_PARAMETERS
  1, // 6 -> RESET_PARAMETERS
};

const std::string& ActionType_Name(
    ActionType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ActionType_entries,
          ActionType_entries_by_number,
          7, ActionType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ActionType_entries,
      ActionType_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ActionType_strings[idx].get();
}
bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ActionType_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<ActionType>(int_value);
  }
  return success;
}
bool ErrorCode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ErrorCode_strings[17] = {};

static const char ErrorCode_names[] =
  "ERROR_COMMUNICATION_TIMEOUT"
  "ERROR_EXTERNAL_NTC_INTERLOCK"
  "ERROR_FIRMWARE_UPDATE"
  "ERROR_INTERLOCK_INPUT"
  "ERROR_INTERNAL_PROBLEM"
  "ERROR_LD_OVERCURRENT"
  "ERROR_LD_OVERHEAT"
  "ERROR_NO_EXTERNAL_NTC_CONNECTED"
  "ERROR_NO_LD_CONNECTED"
  "ERROR_PARAMETER_OUT_OF_RANGE"
  "ERROR_PARSE"
  "ERROR_RESERVED"
  "ERROR_SERIAL_PROTOCOL"
  "ERROR_TEC_ERROR"
  "ERROR_TEC_SELF_HEAT"
  "ERROR_UNKNOWN_COMMAND"
  "ERROR_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ErrorCode_entries[] = {
  { {ErrorCode_names + 0, 27}, 14 },
  { {ErrorCode_names + 27, 28}, 7 },
  { {ErrorCode_names + 55, 21}, 11 },
  { {ErrorCode_names + 76, 21}, 10 },
  { {ErrorCode_names + 97, 22}, 4 },
  { {ErrorCode_names + 119, 20}, 5 },
  { {ErrorCode_names + 139, 17}, 6 },
  { {ErrorCode_names + 156, 31}, 13 },
  { {ErrorCode_names + 187, 21}, 12 },
  { {ErrorCode_names + 208, 28}, 2 },
  { {ErrorCode_names + 236, 11}, 15 },
  { {ErrorCode_names + 247, 14}, 16 },
  { {ErrorCode_names + 261, 21}, 1 },
  { {ErrorCode_names + 282, 15}, 8 },
  { {ErrorCode_names + 297, 19}, 9 },
  { {ErrorCode_names + 316, 21}, 3 },
  { {ErrorCode_names + 337, 17}, 0 },
};

static const int ErrorCode_entries_by_number[] = {
  16, // 0 -> ERROR_UNSPECIFIED
  12, // 1 -> ERROR_SERIAL_PROTOCOL
  9, // 2 -> ERROR_PARAMETER_OUT_OF_RANGE
  15, // 3 -> ERROR_UNKNOWN_COMMAND
  4, // 4 -> ERROR_INTERNAL_PROBLEM
  5, // 5 -> ERROR_LD_OVERCURRENT
  6, // 6 -> ERROR_LD_OVERHEAT
  1, // 7 -> ERROR_EXTERNAL_NTC_INTERLOCK
  13, // 8 -> ERROR_TEC_ERROR
  14, // 9 -> ERROR_TEC_SELF_HEAT
  3, // 10 -> ERROR_INTERLOCK_INPUT
  2, // 11 -> ERROR_FIRMWARE_UPDATE
  8, // 12 -> ERROR_NO_LD_CONNECTED
  7, // 13 -> ERROR_NO_EXTERNAL_NTC_CONNECTED
  0, // 14 -> ERROR_COMMUNICATION_TIMEOUT
  10, // 15 -> ERROR_PARSE
  11, // 16 -> ERROR_RESERVED
};

const std::string& ErrorCode_Name(
    ErrorCode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ErrorCode_entries,
          ErrorCode_entries_by_number,
          17, ErrorCode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ErrorCode_entries,
      ErrorCode_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ErrorCode_strings[idx].get();
}
bool ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorCode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ErrorCode_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<ErrorCode>(int_value);
  }
  return success;
}

// ===================================================================

class DriverCommand::_Internal {
 public:
  static const ::sf8xxx_nm::ConfigureCommand& configure(const DriverCommand* msg);
  static const ::sf8xxx_nm::RequestCommand& request(const DriverCommand* msg);
  static const ::sf8xxx_nm::ActionCommand& action(const DriverCommand* msg);
};

const ::sf8xxx_nm::ConfigureCommand&
DriverCommand::_Internal::configure(const DriverCommand* msg) {
  return *msg->command_.configure_;
}
const ::sf8xxx_nm::RequestCommand&
DriverCommand::_Internal::request(const DriverCommand* msg) {
  return *msg->command_.request_;
}
const ::sf8xxx_nm::ActionCommand&
DriverCommand::_Internal::action(const DriverCommand* msg) {
  return *msg->command_.action_;
}
void DriverCommand::set_allocated_configure(::sf8xxx_nm::ConfigureCommand* configure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_command();
  if (configure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(configure);
    if (message_arena != submessage_arena) {
      configure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configure, submessage_arena);
    }
    set_has_configure();
    command_.configure_ = configure;
  }
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverCommand.configure)
}
void DriverCommand::set_allocated_request(::sf8xxx_nm::RequestCommand* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_command();
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    set_has_request();
    command_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverCommand.request)
}
void DriverCommand::set_allocated_action(::sf8xxx_nm::ActionCommand* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_command();
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    set_has_action();
    command_.action_ = action;
  }
  // @@protoc_insertion_point(field_set_allocated:sf8xxx_nm.DriverCommand.action)
}
DriverCommand::DriverCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.DriverCommand)
}
DriverCommand::DriverCommand(const DriverCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_command();
  switch (from.command_case()) {
    case kConfigure: {
      _internal_mutable_configure()->::sf8xxx_nm::ConfigureCommand::MergeFrom(from._internal_configure());
      break;
    }
    case kRequest: {
      _internal_mutable_request()->::sf8xxx_nm::RequestCommand::MergeFrom(from._internal_request());
      break;
    }
    case kAction: {
      _internal_mutable_action()->::sf8xxx_nm::ActionCommand::MergeFrom(from._internal_action());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.DriverCommand)
}

void DriverCommand::SharedCtor() {
clear_has_command();
}

DriverCommand::~DriverCommand() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.DriverCommand)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DriverCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_command()) {
    clear_command();
  }
}

void DriverCommand::ArenaDtor(void* object) {
  DriverCommand* _this = reinterpret_cast< DriverCommand* >(object);
  (void)_this;
}
void DriverCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DriverCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DriverCommand::clear_command() {
// @@protoc_insertion_point(one_of_clear_start:sf8xxx_nm.DriverCommand)
  switch (command_case()) {
    case kConfigure: {
      if (GetArena() == nullptr) {
        delete command_.configure_;
      }
      break;
    }
    case kRequest: {
      if (GetArena() == nullptr) {
        delete command_.request_;
      }
      break;
    }
    case kAction: {
      if (GetArena() == nullptr) {
        delete command_.action_;
      }
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = COMMAND_NOT_SET;
}


void DriverCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.DriverCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_command();
  _internal_metadata_.Clear<std::string>();
}

const char* DriverCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.ConfigureCommand configure = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_configure(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.RequestCommand request = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.ActionCommand action = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_action(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DriverCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.DriverCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.ConfigureCommand configure = 1;
  if (_internal_has_configure()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::configure(this), target, stream);
  }

  // .sf8xxx_nm.RequestCommand request = 2;
  if (_internal_has_request()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::request(this), target, stream);
  }

  // .sf8xxx_nm.ActionCommand action = 3;
  if (_internal_has_action()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::action(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.DriverCommand)
  return target;
}

size_t DriverCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.DriverCommand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (command_case()) {
    // .sf8xxx_nm.ConfigureCommand configure = 1;
    case kConfigure: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.configure_);
      break;
    }
    // .sf8xxx_nm.RequestCommand request = 2;
    case kRequest: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.request_);
      break;
    }
    // .sf8xxx_nm.ActionCommand action = 3;
    case kAction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *command_.action_);
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriverCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DriverCommand*>(
      &from));
}

void DriverCommand::MergeFrom(const DriverCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.DriverCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.command_case()) {
    case kConfigure: {
      _internal_mutable_configure()->::sf8xxx_nm::ConfigureCommand::MergeFrom(from._internal_configure());
      break;
    }
    case kRequest: {
      _internal_mutable_request()->::sf8xxx_nm::RequestCommand::MergeFrom(from._internal_request());
      break;
    }
    case kAction: {
      _internal_mutable_action()->::sf8xxx_nm::ActionCommand::MergeFrom(from._internal_action());
      break;
    }
    case COMMAND_NOT_SET: {
      break;
    }
  }
}

void DriverCommand::CopyFrom(const DriverCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.DriverCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriverCommand::IsInitialized() const {
  return true;
}

void DriverCommand::InternalSwap(DriverCommand* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(command_, other->command_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string DriverCommand::GetTypeName() const {
  return "sf8xxx_nm.DriverCommand";
}


// ===================================================================

class DriverResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<DriverResponse>()._has_bits_);
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::sf8xxx_nm::LddStatus& ldd_status(const DriverResponse* msg);
  static void set_has_ldd_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sf8xxx_nm::TecStatus& tec_status(const DriverResponse* msg);
  static void set_has_tec_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sf8xxx_nm::DriverStateInfo& driver_state(const DriverResponse* msg);
  static void set_has_driver_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sf8xxx_nm::TecStateInfo& tec_state(const DriverResponse* msg);
  static void set_has_tec_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::sf8xxx_nm::LockStatusInfo& lock_status(const DriverResponse* msg);
  static void set_has_lock_status(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_serial_number(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::sf8xxx_nm::LddStatus&
DriverResponse::_Internal::ldd_status(const DriverResponse* msg) {
  return *msg->ldd_status_;
}
const ::sf8xxx_nm::TecStatus&
DriverResponse::_Internal::tec_status(const DriverResponse* msg) {
  return *msg->tec_status_;
}
const ::sf8xxx_nm::DriverStateInfo&
DriverResponse::_Internal::driver_state(const DriverResponse* msg) {
  return *msg->driver_state_;
}
const ::sf8xxx_nm::TecStateInfo&
DriverResponse::_Internal::tec_state(const DriverResponse* msg) {
  return *msg->tec_state_;
}
const ::sf8xxx_nm::LockStatusInfo&
DriverResponse::_Internal::lock_status(const DriverResponse* msg) {
  return *msg->lock_status_;
}
DriverResponse::DriverResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.DriverResponse)
}
DriverResponse::DriverResponse(const DriverResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_ldd_status()) {
    ldd_status_ = new ::sf8xxx_nm::LddStatus(*from.ldd_status_);
  } else {
    ldd_status_ = nullptr;
  }
  if (from._internal_has_tec_status()) {
    tec_status_ = new ::sf8xxx_nm::TecStatus(*from.tec_status_);
  } else {
    tec_status_ = nullptr;
  }
  if (from._internal_has_driver_state()) {
    driver_state_ = new ::sf8xxx_nm::DriverStateInfo(*from.driver_state_);
  } else {
    driver_state_ = nullptr;
  }
  if (from._internal_has_tec_state()) {
    tec_state_ = new ::sf8xxx_nm::TecStateInfo(*from.tec_state_);
  } else {
    tec_state_ = nullptr;
  }
  if (from._internal_has_lock_status()) {
    lock_status_ = new ::sf8xxx_nm::LockStatusInfo(*from.lock_status_);
  } else {
    lock_status_ = nullptr;
  }
  ::memcpy(&error_code_, &from.error_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&serial_number_) -
    reinterpret_cast<char*>(&error_code_)) + sizeof(serial_number_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.DriverResponse)
}

void DriverResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ldd_status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&serial_number_) -
    reinterpret_cast<char*>(&ldd_status_)) + sizeof(serial_number_));
}

DriverResponse::~DriverResponse() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.DriverResponse)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DriverResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete ldd_status_;
  if (this != internal_default_instance()) delete tec_status_;
  if (this != internal_default_instance()) delete driver_state_;
  if (this != internal_default_instance()) delete tec_state_;
  if (this != internal_default_instance()) delete lock_status_;
}

void DriverResponse::ArenaDtor(void* object) {
  DriverResponse* _this = reinterpret_cast< DriverResponse* >(object);
  (void)_this;
}
void DriverResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DriverResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DriverResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.DriverResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      if (GetArena() == nullptr && ldd_status_ != nullptr) {
        delete ldd_status_;
      }
      ldd_status_ = nullptr;
    }
    if (cached_has_bits & 0x00000002u) {
      if (GetArena() == nullptr && tec_status_ != nullptr) {
        delete tec_status_;
      }
      tec_status_ = nullptr;
    }
    if (cached_has_bits & 0x00000004u) {
      if (GetArena() == nullptr && driver_state_ != nullptr) {
        delete driver_state_;
      }
      driver_state_ = nullptr;
    }
    if (cached_has_bits & 0x00000008u) {
      if (GetArena() == nullptr && tec_state_ != nullptr) {
        delete tec_state_;
      }
      tec_state_ = nullptr;
    }
    if (cached_has_bits & 0x00000010u) {
      if (GetArena() == nullptr && lock_status_ != nullptr) {
        delete lock_status_;
      }
      lock_status_ = nullptr;
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&error_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&serial_number_) -
        reinterpret_cast<char*>(&error_code_)) + sizeof(serial_number_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DriverResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.ErrorCode error_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_error_code(static_cast<::sf8xxx_nm::ErrorCode>(val));
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.LddStatus ldd_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ldd_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.TecStatus tec_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tec_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.DriverStateInfo driver_state = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_driver_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.TecStateInfo tec_state = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_tec_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.LockStatusInfo lock_status = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_lock_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 serial_number = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_serial_number(&has_bits);
          serial_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DriverResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.DriverResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.ErrorCode error_code = 1;
  if (_internal_has_error_code()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_code(), target);
  }

  // .sf8xxx_nm.LddStatus ldd_status = 2;
  if (_internal_has_ldd_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ldd_status(this), target, stream);
  }

  // .sf8xxx_nm.TecStatus tec_status = 3;
  if (_internal_has_tec_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::tec_status(this), target, stream);
  }

  // .sf8xxx_nm.DriverStateInfo driver_state = 4;
  if (_internal_has_driver_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::driver_state(this), target, stream);
  }

  // .sf8xxx_nm.TecStateInfo tec_state = 5;
  if (_internal_has_tec_state()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::tec_state(this), target, stream);
  }

  // .sf8xxx_nm.LockStatusInfo lock_status = 6;
  if (_internal_has_lock_status()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::lock_status(this), target, stream);
  }

  // uint32 serial_number = 7;
  if (_internal_has_serial_number()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_serial_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.DriverResponse)
  return target;
}

size_t DriverResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.DriverResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // .sf8xxx_nm.LddStatus ldd_status = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ldd_status_);
    }

    // .sf8xxx_nm.TecStatus tec_status = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tec_status_);
    }

    // .sf8xxx_nm.DriverStateInfo driver_state = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *driver_state_);
    }

    // .sf8xxx_nm.TecStateInfo tec_state = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tec_state_);
    }

    // .sf8xxx_nm.LockStatusInfo lock_status = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lock_status_);
    }

    // .sf8xxx_nm.ErrorCode error_code = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    // uint32 serial_number = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_serial_number());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriverResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DriverResponse*>(
      &from));
}

void DriverResponse::MergeFrom(const DriverResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.DriverResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_ldd_status()->::sf8xxx_nm::LddStatus::MergeFrom(from._internal_ldd_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_tec_status()->::sf8xxx_nm::TecStatus::MergeFrom(from._internal_tec_status());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_driver_state()->::sf8xxx_nm::DriverStateInfo::MergeFrom(from._internal_driver_state());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_tec_state()->::sf8xxx_nm::TecStateInfo::MergeFrom(from._internal_tec_state());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_lock_status()->::sf8xxx_nm::LockStatusInfo::MergeFrom(from._internal_lock_status());
    }
    if (cached_has_bits & 0x00000020u) {
      error_code_ = from.error_code_;
    }
    if (cached_has_bits & 0x00000040u) {
      serial_number_ = from.serial_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DriverResponse::CopyFrom(const DriverResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.DriverResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriverResponse::IsInitialized() const {
  return true;
}

void DriverResponse::InternalSwap(DriverResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DriverResponse, serial_number_)
      + sizeof(DriverResponse::serial_number_)
      - PROTOBUF_FIELD_OFFSET(DriverResponse, ldd_status_)>(
          reinterpret_cast<char*>(&ldd_status_),
          reinterpret_cast<char*>(&other->ldd_status_));
}

std::string DriverResponse::GetTypeName() const {
  return "sf8xxx_nm.DriverResponse";
}


// ===================================================================

class ConfigureCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureCommand>()._has_bits_);
  static const ::sf8xxx_nm::LddSettings& ldd_settings(const ConfigureCommand* msg);
  static void set_has_ldd_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sf8xxx_nm::TecSettings& tec_settings(const ConfigureCommand* msg);
  static void set_has_tec_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sf8xxx_nm::PidSettings& pid_settings(const ConfigureCommand* msg);
  static void set_has_pid_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sf8xxx_nm::NtcInterlockSettings& ntc_interlock_settings(const ConfigureCommand* msg);
  static void set_has_ntc_interlock_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::sf8xxx_nm::DriverStateSettings& driver_state_settings(const ConfigureCommand* msg);
  static void set_has_driver_state_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::sf8xxx_nm::TecStateSettings& tec_state_settings(const ConfigureCommand* msg);
  static void set_has_tec_state_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::sf8xxx_nm::LddSettings&
ConfigureCommand::_Internal::ldd_settings(const ConfigureCommand* msg) {
  return *msg->ldd_settings_;
}
const ::sf8xxx_nm::TecSettings&
ConfigureCommand::_Internal::tec_settings(const ConfigureCommand* msg) {
  return *msg->tec_settings_;
}
const ::sf8xxx_nm::PidSettings&
ConfigureCommand::_Internal::pid_settings(const ConfigureCommand* msg) {
  return *msg->pid_settings_;
}
const ::sf8xxx_nm::NtcInterlockSettings&
ConfigureCommand::_Internal::ntc_interlock_settings(const ConfigureCommand* msg) {
  return *msg->ntc_interlock_settings_;
}
const ::sf8xxx_nm::DriverStateSettings&
ConfigureCommand::_Internal::driver_state_settings(const ConfigureCommand* msg) {
  return *msg->driver_state_settings_;
}
const ::sf8xxx_nm::TecStateSettings&
ConfigureCommand::_Internal::tec_state_settings(const ConfigureCommand* msg) {
  return *msg->tec_state_settings_;
}
ConfigureCommand::ConfigureCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.ConfigureCommand)
}
ConfigureCommand::ConfigureCommand(const ConfigureCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_ldd_settings()) {
    ldd_settings_ = new ::sf8xxx_nm::LddSettings(*from.ldd_settings_);
  } else {
    ldd_settings_ = nullptr;
  }
  if (from._internal_has_tec_settings()) {
    tec_settings_ = new ::sf8xxx_nm::TecSettings(*from.tec_settings_);
  } else {
    tec_settings_ = nullptr;
  }
  if (from._internal_has_pid_settings()) {
    pid_settings_ = new ::sf8xxx_nm::PidSettings(*from.pid_settings_);
  } else {
    pid_settings_ = nullptr;
  }
  if (from._internal_has_ntc_interlock_settings()) {
    ntc_interlock_settings_ = new ::sf8xxx_nm::NtcInterlockSettings(*from.ntc_interlock_settings_);
  } else {
    ntc_interlock_settings_ = nullptr;
  }
  if (from._internal_has_driver_state_settings()) {
    driver_state_settings_ = new ::sf8xxx_nm::DriverStateSettings(*from.driver_state_settings_);
  } else {
    driver_state_settings_ = nullptr;
  }
  if (from._internal_has_tec_state_settings()) {
    tec_state_settings_ = new ::sf8xxx_nm::TecStateSettings(*from.tec_state_settings_);
  } else {
    tec_state_settings_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.ConfigureCommand)
}

void ConfigureCommand::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ldd_settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tec_state_settings_) -
    reinterpret_cast<char*>(&ldd_settings_)) + sizeof(tec_state_settings_));
}

ConfigureCommand::~ConfigureCommand() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.ConfigureCommand)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ConfigureCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete ldd_settings_;
  if (this != internal_default_instance()) delete tec_settings_;
  if (this != internal_default_instance()) delete pid_settings_;
  if (this != internal_default_instance()) delete ntc_interlock_settings_;
  if (this != internal_default_instance()) delete driver_state_settings_;
  if (this != internal_default_instance()) delete tec_state_settings_;
}

void ConfigureCommand::ArenaDtor(void* object) {
  ConfigureCommand* _this = reinterpret_cast< ConfigureCommand* >(object);
  (void)_this;
}
void ConfigureCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfigureCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.ConfigureCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      if (GetArena() == nullptr && ldd_settings_ != nullptr) {
        delete ldd_settings_;
      }
      ldd_settings_ = nullptr;
    }
    if (cached_has_bits & 0x00000002u) {
      if (GetArena() == nullptr && tec_settings_ != nullptr) {
        delete tec_settings_;
      }
      tec_settings_ = nullptr;
    }
    if (cached_has_bits & 0x00000004u) {
      if (GetArena() == nullptr && pid_settings_ != nullptr) {
        delete pid_settings_;
      }
      pid_settings_ = nullptr;
    }
    if (cached_has_bits & 0x00000008u) {
      if (GetArena() == nullptr && ntc_interlock_settings_ != nullptr) {
        delete ntc_interlock_settings_;
      }
      ntc_interlock_settings_ = nullptr;
    }
    if (cached_has_bits & 0x00000010u) {
      if (GetArena() == nullptr && driver_state_settings_ != nullptr) {
        delete driver_state_settings_;
      }
      driver_state_settings_ = nullptr;
    }
    if (cached_has_bits & 0x00000020u) {
      if (GetArena() == nullptr && tec_state_settings_ != nullptr) {
        delete tec_state_settings_;
      }
      tec_state_settings_ = nullptr;
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ConfigureCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.LddSettings ldd_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ldd_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.TecSettings tec_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tec_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.PidSettings pid_settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pid_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.NtcInterlockSettings ntc_interlock_settings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ntc_interlock_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.DriverStateSettings driver_state_settings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_driver_state_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.TecStateSettings tec_state_settings = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_tec_state_settings(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ConfigureCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.ConfigureCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.LddSettings ldd_settings = 1;
  if (_internal_has_ldd_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::ldd_settings(this), target, stream);
  }

  // .sf8xxx_nm.TecSettings tec_settings = 2;
  if (_internal_has_tec_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::tec_settings(this), target, stream);
  }

  // .sf8xxx_nm.PidSettings pid_settings = 3;
  if (_internal_has_pid_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::pid_settings(this), target, stream);
  }

  // .sf8xxx_nm.NtcInterlockSettings ntc_interlock_settings = 4;
  if (_internal_has_ntc_interlock_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::ntc_interlock_settings(this), target, stream);
  }

  // .sf8xxx_nm.DriverStateSettings driver_state_settings = 5;
  if (_internal_has_driver_state_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::driver_state_settings(this), target, stream);
  }

  // .sf8xxx_nm.TecStateSettings tec_state_settings = 6;
  if (_internal_has_tec_state_settings()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::tec_state_settings(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.ConfigureCommand)
  return target;
}

size_t ConfigureCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.ConfigureCommand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // .sf8xxx_nm.LddSettings ldd_settings = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ldd_settings_);
    }

    // .sf8xxx_nm.TecSettings tec_settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tec_settings_);
    }

    // .sf8xxx_nm.PidSettings pid_settings = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pid_settings_);
    }

    // .sf8xxx_nm.NtcInterlockSettings ntc_interlock_settings = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ntc_interlock_settings_);
    }

    // .sf8xxx_nm.DriverStateSettings driver_state_settings = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *driver_state_settings_);
    }

    // .sf8xxx_nm.TecStateSettings tec_state_settings = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tec_state_settings_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ConfigureCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ConfigureCommand*>(
      &from));
}

void ConfigureCommand::MergeFrom(const ConfigureCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.ConfigureCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_ldd_settings()->::sf8xxx_nm::LddSettings::MergeFrom(from._internal_ldd_settings());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_tec_settings()->::sf8xxx_nm::TecSettings::MergeFrom(from._internal_tec_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_pid_settings()->::sf8xxx_nm::PidSettings::MergeFrom(from._internal_pid_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_ntc_interlock_settings()->::sf8xxx_nm::NtcInterlockSettings::MergeFrom(from._internal_ntc_interlock_settings());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_driver_state_settings()->::sf8xxx_nm::DriverStateSettings::MergeFrom(from._internal_driver_state_settings());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_tec_state_settings()->::sf8xxx_nm::TecStateSettings::MergeFrom(from._internal_tec_state_settings());
    }
  }
}

void ConfigureCommand::CopyFrom(const ConfigureCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.ConfigureCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureCommand::IsInitialized() const {
  return true;
}

void ConfigureCommand::InternalSwap(ConfigureCommand* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureCommand, tec_state_settings_)
      + sizeof(ConfigureCommand::tec_state_settings_)
      - PROTOBUF_FIELD_OFFSET(ConfigureCommand, ldd_settings_)>(
          reinterpret_cast<char*>(&ldd_settings_),
          reinterpret_cast<char*>(&other->ldd_settings_));
}

std::string ConfigureCommand::GetTypeName() const {
  return "sf8xxx_nm.ConfigureCommand";
}


// ===================================================================

class LddSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<LddSettings>()._has_bits_);
  static void set_has_frequency_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_duration_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_ma(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_current_max_ma(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_current_calibration_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

LddSettings::LddSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.LddSettings)
}
LddSettings::LddSettings(const LddSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&frequency_hz_, &from.frequency_hz_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_calibration_percent_) -
    reinterpret_cast<char*>(&frequency_hz_)) + sizeof(current_calibration_percent_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.LddSettings)
}

void LddSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frequency_hz_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_calibration_percent_) -
    reinterpret_cast<char*>(&frequency_hz_)) + sizeof(current_calibration_percent_));
}

LddSettings::~LddSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.LddSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LddSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LddSettings::ArenaDtor(void* object) {
  LddSettings* _this = reinterpret_cast< LddSettings* >(object);
  (void)_this;
}
void LddSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LddSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LddSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.LddSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&frequency_hz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_calibration_percent_) -
        reinterpret_cast<char*>(&frequency_hz_)) + sizeof(current_calibration_percent_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* LddSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float frequency_hz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_frequency_hz(&has_bits);
          frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float duration_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_duration_ms(&has_bits);
          duration_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_ma = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_current_ma(&has_bits);
          current_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_max_ma = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_current_max_ma(&has_bits);
          current_max_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_calibration_percent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_current_calibration_percent(&has_bits);
          current_calibration_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LddSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.LddSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float frequency_hz = 1;
  if (_internal_has_frequency_hz()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_frequency_hz(), target);
  }

  // float duration_ms = 2;
  if (_internal_has_duration_ms()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_duration_ms(), target);
  }

  // float current_ma = 3;
  if (_internal_has_current_ma()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_current_ma(), target);
  }

  // float current_max_ma = 4;
  if (_internal_has_current_max_ma()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_current_max_ma(), target);
  }

  // float current_calibration_percent = 5;
  if (_internal_has_current_calibration_percent()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_current_calibration_percent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.LddSettings)
  return target;
}

size_t LddSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.LddSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // float frequency_hz = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float duration_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float current_ma = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float current_max_ma = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float current_calibration_percent = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LddSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LddSettings*>(
      &from));
}

void LddSettings::MergeFrom(const LddSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.LddSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      frequency_hz_ = from.frequency_hz_;
    }
    if (cached_has_bits & 0x00000002u) {
      duration_ms_ = from.duration_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      current_ma_ = from.current_ma_;
    }
    if (cached_has_bits & 0x00000008u) {
      current_max_ma_ = from.current_max_ma_;
    }
    if (cached_has_bits & 0x00000010u) {
      current_calibration_percent_ = from.current_calibration_percent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LddSettings::CopyFrom(const LddSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.LddSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LddSettings::IsInitialized() const {
  return true;
}

void LddSettings::InternalSwap(LddSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LddSettings, current_calibration_percent_)
      + sizeof(LddSettings::current_calibration_percent_)
      - PROTOBUF_FIELD_OFFSET(LddSettings, frequency_hz_)>(
          reinterpret_cast<char*>(&frequency_hz_),
          reinterpret_cast<char*>(&other->frequency_hz_));
}

std::string LddSettings::GetTypeName() const {
  return "sf8xxx_nm.LddSettings";
}


// ===================================================================

class TecSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<TecSettings>()._has_bits_);
  static void set_has_temperature_celsius(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_temp_max_celsius(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_temp_min_celsius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_current_limit_a(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_calibration_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_internal_ntc_b_coefficient(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TecSettings::TecSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.TecSettings)
}
TecSettings::TecSettings(const TecSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&temperature_celsius_, &from.temperature_celsius_,
    static_cast<size_t>(reinterpret_cast<char*>(&internal_ntc_b_coefficient_) -
    reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(internal_ntc_b_coefficient_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.TecSettings)
}

void TecSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&temperature_celsius_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&internal_ntc_b_coefficient_) -
    reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(internal_ntc_b_coefficient_));
}

TecSettings::~TecSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.TecSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TecSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TecSettings::ArenaDtor(void* object) {
  TecSettings* _this = reinterpret_cast< TecSettings* >(object);
  (void)_this;
}
void TecSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TecSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TecSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.TecSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&temperature_celsius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&internal_ntc_b_coefficient_) -
        reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(internal_ntc_b_coefficient_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TecSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float temperature_celsius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_temperature_celsius(&has_bits);
          temperature_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_max_celsius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_temp_max_celsius(&has_bits);
          temp_max_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_min_celsius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_temp_min_celsius(&has_bits);
          temp_min_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_limit_a = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_current_limit_a(&has_bits);
          current_limit_a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float calibration_percent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_calibration_percent(&has_bits);
          calibration_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // uint32 internal_ntc_b_coefficient = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_internal_ntc_b_coefficient(&has_bits);
          internal_ntc_b_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TecSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.TecSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float temperature_celsius = 1;
  if (_internal_has_temperature_celsius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_temperature_celsius(), target);
  }

  // float temp_max_celsius = 2;
  if (_internal_has_temp_max_celsius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_temp_max_celsius(), target);
  }

  // float temp_min_celsius = 3;
  if (_internal_has_temp_min_celsius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_temp_min_celsius(), target);
  }

  // float current_limit_a = 4;
  if (_internal_has_current_limit_a()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_current_limit_a(), target);
  }

  // float calibration_percent = 5;
  if (_internal_has_calibration_percent()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_calibration_percent(), target);
  }

  // uint32 internal_ntc_b_coefficient = 6;
  if (_internal_has_internal_ntc_b_coefficient()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_internal_ntc_b_coefficient(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.TecSettings)
  return target;
}

size_t TecSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.TecSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // float temperature_celsius = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float temp_max_celsius = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // float temp_min_celsius = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // float current_limit_a = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // float calibration_percent = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // uint32 internal_ntc_b_coefficient = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_internal_ntc_b_coefficient());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TecSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TecSettings*>(
      &from));
}

void TecSettings::MergeFrom(const TecSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.TecSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      temperature_celsius_ = from.temperature_celsius_;
    }
    if (cached_has_bits & 0x00000002u) {
      temp_max_celsius_ = from.temp_max_celsius_;
    }
    if (cached_has_bits & 0x00000004u) {
      temp_min_celsius_ = from.temp_min_celsius_;
    }
    if (cached_has_bits & 0x00000008u) {
      current_limit_a_ = from.current_limit_a_;
    }
    if (cached_has_bits & 0x00000010u) {
      calibration_percent_ = from.calibration_percent_;
    }
    if (cached_has_bits & 0x00000020u) {
      internal_ntc_b_coefficient_ = from.internal_ntc_b_coefficient_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TecSettings::CopyFrom(const TecSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.TecSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TecSettings::IsInitialized() const {
  return true;
}

void TecSettings::InternalSwap(TecSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TecSettings, internal_ntc_b_coefficient_)
      + sizeof(TecSettings::internal_ntc_b_coefficient_)
      - PROTOBUF_FIELD_OFFSET(TecSettings, temperature_celsius_)>(
          reinterpret_cast<char*>(&temperature_celsius_),
          reinterpret_cast<char*>(&other->temperature_celsius_));
}

std::string TecSettings::GetTypeName() const {
  return "sf8xxx_nm.TecSettings";
}


// ===================================================================

class PidSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<PidSettings>()._has_bits_);
  static void set_has_p_coefficient(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_i_coefficient(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_d_coefficient(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PidSettings::PidSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.PidSettings)
}
PidSettings::PidSettings(const PidSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&p_coefficient_, &from.p_coefficient_,
    static_cast<size_t>(reinterpret_cast<char*>(&d_coefficient_) -
    reinterpret_cast<char*>(&p_coefficient_)) + sizeof(d_coefficient_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.PidSettings)
}

void PidSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&p_coefficient_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&d_coefficient_) -
    reinterpret_cast<char*>(&p_coefficient_)) + sizeof(d_coefficient_));
}

PidSettings::~PidSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.PidSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void PidSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PidSettings::ArenaDtor(void* object) {
  PidSettings* _this = reinterpret_cast< PidSettings* >(object);
  (void)_this;
}
void PidSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PidSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PidSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.PidSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&p_coefficient_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&d_coefficient_) -
        reinterpret_cast<char*>(&p_coefficient_)) + sizeof(d_coefficient_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PidSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 p_coefficient = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_p_coefficient(&has_bits);
          p_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 i_coefficient = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_i_coefficient(&has_bits);
          i_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 d_coefficient = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_d_coefficient(&has_bits);
          d_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PidSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.PidSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 p_coefficient = 1;
  if (_internal_has_p_coefficient()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_p_coefficient(), target);
  }

  // uint32 i_coefficient = 2;
  if (_internal_has_i_coefficient()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_i_coefficient(), target);
  }

  // uint32 d_coefficient = 3;
  if (_internal_has_d_coefficient()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_d_coefficient(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.PidSettings)
  return target;
}

size_t PidSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.PidSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // uint32 p_coefficient = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_p_coefficient());
    }

    // uint32 i_coefficient = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_i_coefficient());
    }

    // uint32 d_coefficient = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_d_coefficient());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PidSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const PidSettings*>(
      &from));
}

void PidSettings::MergeFrom(const PidSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.PidSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      p_coefficient_ = from.p_coefficient_;
    }
    if (cached_has_bits & 0x00000002u) {
      i_coefficient_ = from.i_coefficient_;
    }
    if (cached_has_bits & 0x00000004u) {
      d_coefficient_ = from.d_coefficient_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PidSettings::CopyFrom(const PidSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.PidSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PidSettings::IsInitialized() const {
  return true;
}

void PidSettings::InternalSwap(PidSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PidSettings, d_coefficient_)
      + sizeof(PidSettings::d_coefficient_)
      - PROTOBUF_FIELD_OFFSET(PidSettings, p_coefficient_)>(
          reinterpret_cast<char*>(&p_coefficient_),
          reinterpret_cast<char*>(&other->p_coefficient_));
}

std::string PidSettings::GetTypeName() const {
  return "sf8xxx_nm.PidSettings";
}


// ===================================================================

class NtcInterlockSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<NtcInterlockSettings>()._has_bits_);
  static void set_has_lower_limit_celsius(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_upper_limit_celsius(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_b_coefficient(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

NtcInterlockSettings::NtcInterlockSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.NtcInterlockSettings)
}
NtcInterlockSettings::NtcInterlockSettings(const NtcInterlockSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&lower_limit_celsius_, &from.lower_limit_celsius_,
    static_cast<size_t>(reinterpret_cast<char*>(&b_coefficient_) -
    reinterpret_cast<char*>(&lower_limit_celsius_)) + sizeof(b_coefficient_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.NtcInterlockSettings)
}

void NtcInterlockSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&lower_limit_celsius_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&b_coefficient_) -
    reinterpret_cast<char*>(&lower_limit_celsius_)) + sizeof(b_coefficient_));
}

NtcInterlockSettings::~NtcInterlockSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.NtcInterlockSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void NtcInterlockSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void NtcInterlockSettings::ArenaDtor(void* object) {
  NtcInterlockSettings* _this = reinterpret_cast< NtcInterlockSettings* >(object);
  (void)_this;
}
void NtcInterlockSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NtcInterlockSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NtcInterlockSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.NtcInterlockSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&lower_limit_celsius_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&b_coefficient_) -
        reinterpret_cast<char*>(&lower_limit_celsius_)) + sizeof(b_coefficient_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NtcInterlockSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float lower_limit_celsius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_lower_limit_celsius(&has_bits);
          lower_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float upper_limit_celsius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_upper_limit_celsius(&has_bits);
          upper_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // uint32 b_coefficient = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_b_coefficient(&has_bits);
          b_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NtcInterlockSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.NtcInterlockSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float lower_limit_celsius = 1;
  if (_internal_has_lower_limit_celsius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_lower_limit_celsius(), target);
  }

  // float upper_limit_celsius = 2;
  if (_internal_has_upper_limit_celsius()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_upper_limit_celsius(), target);
  }

  // uint32 b_coefficient = 3;
  if (_internal_has_b_coefficient()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_b_coefficient(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.NtcInterlockSettings)
  return target;
}

size_t NtcInterlockSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.NtcInterlockSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // float lower_limit_celsius = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // float upper_limit_celsius = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // uint32 b_coefficient = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_b_coefficient());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NtcInterlockSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const NtcInterlockSettings*>(
      &from));
}

void NtcInterlockSettings::MergeFrom(const NtcInterlockSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.NtcInterlockSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      lower_limit_celsius_ = from.lower_limit_celsius_;
    }
    if (cached_has_bits & 0x00000002u) {
      upper_limit_celsius_ = from.upper_limit_celsius_;
    }
    if (cached_has_bits & 0x00000004u) {
      b_coefficient_ = from.b_coefficient_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NtcInterlockSettings::CopyFrom(const NtcInterlockSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.NtcInterlockSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtcInterlockSettings::IsInitialized() const {
  return true;
}

void NtcInterlockSettings::InternalSwap(NtcInterlockSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NtcInterlockSettings, b_coefficient_)
      + sizeof(NtcInterlockSettings::b_coefficient_)
      - PROTOBUF_FIELD_OFFSET(NtcInterlockSettings, lower_limit_celsius_)>(
          reinterpret_cast<char*>(&lower_limit_celsius_),
          reinterpret_cast<char*>(&other->lower_limit_celsius_));
}

std::string NtcInterlockSettings::GetTypeName() const {
  return "sf8xxx_nm.NtcInterlockSettings";
}


// ===================================================================

class DriverStateSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<DriverStateSettings>()._has_bits_);
  static void set_has_current_set_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_interlock_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ntc_interlock_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DriverStateSettings::DriverStateSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.DriverStateSettings)
}
DriverStateSettings::DriverStateSettings(const DriverStateSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&current_set_source_, &from.current_set_source_,
    static_cast<size_t>(reinterpret_cast<char*>(&ntc_interlock_policy_) -
    reinterpret_cast<char*>(&current_set_source_)) + sizeof(ntc_interlock_policy_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.DriverStateSettings)
}

void DriverStateSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&current_set_source_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ntc_interlock_policy_) -
    reinterpret_cast<char*>(&current_set_source_)) + sizeof(ntc_interlock_policy_));
}

DriverStateSettings::~DriverStateSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.DriverStateSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DriverStateSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void DriverStateSettings::ArenaDtor(void* object) {
  DriverStateSettings* _this = reinterpret_cast< DriverStateSettings* >(object);
  (void)_this;
}
void DriverStateSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DriverStateSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DriverStateSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.DriverStateSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&current_set_source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ntc_interlock_policy_) -
        reinterpret_cast<char*>(&current_set_source_)) + sizeof(ntc_interlock_policy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DriverStateSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.DriverStateSettings.CurrentSetSource current_set_source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_current_set_source(static_cast<::sf8xxx_nm::DriverStateSettings_CurrentSetSource>(val));
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.DriverStateSettings.EnableSource enable_source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_enable_source(static_cast<::sf8xxx_nm::DriverStateSettings_EnableSource>(val));
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.DriverStateSettings.InterlockPolicy interlock_policy = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_interlock_policy(static_cast<::sf8xxx_nm::DriverStateSettings_InterlockPolicy>(val));
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.DriverStateSettings.NtcInterlockPolicy ntc_interlock_policy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ntc_interlock_policy(static_cast<::sf8xxx_nm::DriverStateSettings_NtcInterlockPolicy>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DriverStateSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.DriverStateSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.DriverStateSettings.CurrentSetSource current_set_source = 1;
  if (_internal_has_current_set_source()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_current_set_source(), target);
  }

  // .sf8xxx_nm.DriverStateSettings.EnableSource enable_source = 2;
  if (_internal_has_enable_source()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_enable_source(), target);
  }

  // .sf8xxx_nm.DriverStateSettings.InterlockPolicy interlock_policy = 3;
  if (_internal_has_interlock_policy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_interlock_policy(), target);
  }

  // .sf8xxx_nm.DriverStateSettings.NtcInterlockPolicy ntc_interlock_policy = 4;
  if (_internal_has_ntc_interlock_policy()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_ntc_interlock_policy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.DriverStateSettings)
  return target;
}

size_t DriverStateSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.DriverStateSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // .sf8xxx_nm.DriverStateSettings.CurrentSetSource current_set_source = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_current_set_source());
    }

    // .sf8xxx_nm.DriverStateSettings.EnableSource enable_source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_enable_source());
    }

    // .sf8xxx_nm.DriverStateSettings.InterlockPolicy interlock_policy = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_interlock_policy());
    }

    // .sf8xxx_nm.DriverStateSettings.NtcInterlockPolicy ntc_interlock_policy = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ntc_interlock_policy());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriverStateSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DriverStateSettings*>(
      &from));
}

void DriverStateSettings::MergeFrom(const DriverStateSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.DriverStateSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      current_set_source_ = from.current_set_source_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_source_ = from.enable_source_;
    }
    if (cached_has_bits & 0x00000004u) {
      interlock_policy_ = from.interlock_policy_;
    }
    if (cached_has_bits & 0x00000008u) {
      ntc_interlock_policy_ = from.ntc_interlock_policy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DriverStateSettings::CopyFrom(const DriverStateSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.DriverStateSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriverStateSettings::IsInitialized() const {
  return true;
}

void DriverStateSettings::InternalSwap(DriverStateSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DriverStateSettings, ntc_interlock_policy_)
      + sizeof(DriverStateSettings::ntc_interlock_policy_)
      - PROTOBUF_FIELD_OFFSET(DriverStateSettings, current_set_source_)>(
          reinterpret_cast<char*>(&current_set_source_),
          reinterpret_cast<char*>(&other->current_set_source_));
}

std::string DriverStateSettings::GetTypeName() const {
  return "sf8xxx_nm.DriverStateSettings";
}


// ===================================================================

class TecStateSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<TecStateSettings>()._has_bits_);
  static void set_has_temp_set_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_source(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TecStateSettings::TecStateSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.TecStateSettings)
}
TecStateSettings::TecStateSettings(const TecStateSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&temp_set_source_, &from.temp_set_source_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_source_) -
    reinterpret_cast<char*>(&temp_set_source_)) + sizeof(enable_source_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.TecStateSettings)
}

void TecStateSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&temp_set_source_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_source_) -
    reinterpret_cast<char*>(&temp_set_source_)) + sizeof(enable_source_));
}

TecStateSettings::~TecStateSettings() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.TecStateSettings)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TecStateSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TecStateSettings::ArenaDtor(void* object) {
  TecStateSettings* _this = reinterpret_cast< TecStateSettings* >(object);
  (void)_this;
}
void TecStateSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TecStateSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TecStateSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.TecStateSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&temp_set_source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_source_) -
        reinterpret_cast<char*>(&temp_set_source_)) + sizeof(enable_source_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TecStateSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.TecStateSettings.TempSetSource temp_set_source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_temp_set_source(static_cast<::sf8xxx_nm::TecStateSettings_TempSetSource>(val));
        } else goto handle_unusual;
        continue;
      // .sf8xxx_nm.TecStateSettings.EnableSource enable_source = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_enable_source(static_cast<::sf8xxx_nm::TecStateSettings_EnableSource>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TecStateSettings::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.TecStateSettings)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.TecStateSettings.TempSetSource temp_set_source = 1;
  if (_internal_has_temp_set_source()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_temp_set_source(), target);
  }

  // .sf8xxx_nm.TecStateSettings.EnableSource enable_source = 2;
  if (_internal_has_enable_source()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_enable_source(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.TecStateSettings)
  return target;
}

size_t TecStateSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.TecStateSettings)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .sf8xxx_nm.TecStateSettings.TempSetSource temp_set_source = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_temp_set_source());
    }

    // .sf8xxx_nm.TecStateSettings.EnableSource enable_source = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_enable_source());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TecStateSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TecStateSettings*>(
      &from));
}

void TecStateSettings::MergeFrom(const TecStateSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.TecStateSettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      temp_set_source_ = from.temp_set_source_;
    }
    if (cached_has_bits & 0x00000002u) {
      enable_source_ = from.enable_source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TecStateSettings::CopyFrom(const TecStateSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.TecStateSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TecStateSettings::IsInitialized() const {
  return true;
}

void TecStateSettings::InternalSwap(TecStateSettings* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TecStateSettings, enable_source_)
      + sizeof(TecStateSettings::enable_source_)
      - PROTOBUF_FIELD_OFFSET(TecStateSettings, temp_set_source_)>(
          reinterpret_cast<char*>(&temp_set_source_),
          reinterpret_cast<char*>(&other->temp_set_source_));
}

std::string TecStateSettings::GetTypeName() const {
  return "sf8xxx_nm.TecStateSettings";
}


// ===================================================================

class RequestCommand::_Internal {
 public:
};

RequestCommand::RequestCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  requests_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.RequestCommand)
}
RequestCommand::RequestCommand(const RequestCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      requests_(from.requests_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.RequestCommand)
}

void RequestCommand::SharedCtor() {
}

RequestCommand::~RequestCommand() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.RequestCommand)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void RequestCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void RequestCommand::ArenaDtor(void* object) {
  RequestCommand* _this = reinterpret_cast< RequestCommand* >(object);
  (void)_this;
}
void RequestCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RequestCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RequestCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.RequestCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  requests_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RequestCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .sf8xxx_nm.RequestType requests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_requests(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_requests(static_cast<::sf8xxx_nm::RequestType>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RequestCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.RequestCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sf8xxx_nm.RequestType requests = 1;
  {
    int byte_size = _requests_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          1, requests_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.RequestCommand)
  return target;
}

size_t RequestCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.RequestCommand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sf8xxx_nm.RequestType requests = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_requests_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_requests(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _requests_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RequestCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const RequestCommand*>(
      &from));
}

void RequestCommand::MergeFrom(const RequestCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.RequestCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  requests_.MergeFrom(from.requests_);
}

void RequestCommand::CopyFrom(const RequestCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.RequestCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCommand::IsInitialized() const {
  return true;
}

void RequestCommand::InternalSwap(RequestCommand* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  requests_.InternalSwap(&other->requests_);
}

std::string RequestCommand::GetTypeName() const {
  return "sf8xxx_nm.RequestCommand";
}


// ===================================================================

class ActionCommand::_Internal {
 public:
};

ActionCommand::ActionCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.ActionCommand)
}
ActionCommand::ActionCommand(const ActionCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.ActionCommand)
}

void ActionCommand::SharedCtor() {
type_ = 0;
}

ActionCommand::~ActionCommand() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.ActionCommand)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void ActionCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ActionCommand::ArenaDtor(void* object) {
  ActionCommand* _this = reinterpret_cast< ActionCommand* >(object);
  (void)_this;
}
void ActionCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ActionCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ActionCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.ActionCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* ActionCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .sf8xxx_nm.ActionType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::sf8xxx_nm::ActionType>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ActionCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.ActionCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sf8xxx_nm.ActionType type = 1;
  if (this->type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.ActionCommand)
  return target;
}

size_t ActionCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.ActionCommand)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .sf8xxx_nm.ActionType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ActionCommand::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ActionCommand*>(
      &from));
}

void ActionCommand::MergeFrom(const ActionCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.ActionCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.type() != 0) {
    _internal_set_type(from._internal_type());
  }
}

void ActionCommand::CopyFrom(const ActionCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.ActionCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActionCommand::IsInitialized() const {
  return true;
}

void ActionCommand::InternalSwap(ActionCommand* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(type_, other->type_);
}

std::string ActionCommand::GetTypeName() const {
  return "sf8xxx_nm.ActionCommand";
}


// ===================================================================

class LddStatus::_Internal {
 public:
};

LddStatus::LddStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.LddStatus)
}
LddStatus::LddStatus(const LddStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&frequency_hz_, &from.frequency_hz_,
    static_cast<size_t>(reinterpret_cast<char*>(&measured_voltage_v_) -
    reinterpret_cast<char*>(&frequency_hz_)) + sizeof(measured_voltage_v_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.LddStatus)
}

void LddStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frequency_hz_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&measured_voltage_v_) -
    reinterpret_cast<char*>(&frequency_hz_)) + sizeof(measured_voltage_v_));
}

LddStatus::~LddStatus() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.LddStatus)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LddStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LddStatus::ArenaDtor(void* object) {
  LddStatus* _this = reinterpret_cast< LddStatus* >(object);
  (void)_this;
}
void LddStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LddStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LddStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.LddStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&frequency_hz_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&measured_voltage_v_) -
      reinterpret_cast<char*>(&frequency_hz_)) + sizeof(measured_voltage_v_));
  _internal_metadata_.Clear<std::string>();
}

const char* LddStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float frequency_hz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          frequency_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float frequency_min_hz = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          frequency_min_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float frequency_max_hz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          frequency_max_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float duration_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          duration_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float duration_min_ms = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          duration_min_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float duration_max_ms = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          duration_max_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_ma = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          current_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_min_ma = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          current_min_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_max_ma = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          current_max_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_max_limit_ma = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          current_max_limit_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float measured_current_ma = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          measured_current_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_protection_threshold_ma = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          current_protection_threshold_ma_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_calibration_percent = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 109)) {
          current_calibration_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float measured_voltage_v = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          measured_voltage_v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LddStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.LddStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float frequency_hz = 1;
  if (!(this->frequency_hz() <= 0 && this->frequency_hz() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_frequency_hz(), target);
  }

  // float frequency_min_hz = 2;
  if (!(this->frequency_min_hz() <= 0 && this->frequency_min_hz() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_frequency_min_hz(), target);
  }

  // float frequency_max_hz = 3;
  if (!(this->frequency_max_hz() <= 0 && this->frequency_max_hz() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_frequency_max_hz(), target);
  }

  // float duration_ms = 4;
  if (!(this->duration_ms() <= 0 && this->duration_ms() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_duration_ms(), target);
  }

  // float duration_min_ms = 5;
  if (!(this->duration_min_ms() <= 0 && this->duration_min_ms() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_duration_min_ms(), target);
  }

  // float duration_max_ms = 6;
  if (!(this->duration_max_ms() <= 0 && this->duration_max_ms() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_duration_max_ms(), target);
  }

  // float current_ma = 7;
  if (!(this->current_ma() <= 0 && this->current_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_current_ma(), target);
  }

  // float current_min_ma = 8;
  if (!(this->current_min_ma() <= 0 && this->current_min_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_current_min_ma(), target);
  }

  // float current_max_ma = 9;
  if (!(this->current_max_ma() <= 0 && this->current_max_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_current_max_ma(), target);
  }

  // float current_max_limit_ma = 10;
  if (!(this->current_max_limit_ma() <= 0 && this->current_max_limit_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_current_max_limit_ma(), target);
  }

  // float measured_current_ma = 11;
  if (!(this->measured_current_ma() <= 0 && this->measured_current_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_measured_current_ma(), target);
  }

  // float current_protection_threshold_ma = 12;
  if (!(this->current_protection_threshold_ma() <= 0 && this->current_protection_threshold_ma() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_current_protection_threshold_ma(), target);
  }

  // float current_calibration_percent = 13;
  if (!(this->current_calibration_percent() <= 0 && this->current_calibration_percent() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_current_calibration_percent(), target);
  }

  // float measured_voltage_v = 14;
  if (!(this->measured_voltage_v() <= 0 && this->measured_voltage_v() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_measured_voltage_v(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.LddStatus)
  return target;
}

size_t LddStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.LddStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float frequency_hz = 1;
  if (!(this->frequency_hz() <= 0 && this->frequency_hz() >= 0)) {
    total_size += 1 + 4;
  }

  // float frequency_min_hz = 2;
  if (!(this->frequency_min_hz() <= 0 && this->frequency_min_hz() >= 0)) {
    total_size += 1 + 4;
  }

  // float frequency_max_hz = 3;
  if (!(this->frequency_max_hz() <= 0 && this->frequency_max_hz() >= 0)) {
    total_size += 1 + 4;
  }

  // float duration_ms = 4;
  if (!(this->duration_ms() <= 0 && this->duration_ms() >= 0)) {
    total_size += 1 + 4;
  }

  // float duration_min_ms = 5;
  if (!(this->duration_min_ms() <= 0 && this->duration_min_ms() >= 0)) {
    total_size += 1 + 4;
  }

  // float duration_max_ms = 6;
  if (!(this->duration_max_ms() <= 0 && this->duration_max_ms() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_ma = 7;
  if (!(this->current_ma() <= 0 && this->current_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_min_ma = 8;
  if (!(this->current_min_ma() <= 0 && this->current_min_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_max_ma = 9;
  if (!(this->current_max_ma() <= 0 && this->current_max_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_max_limit_ma = 10;
  if (!(this->current_max_limit_ma() <= 0 && this->current_max_limit_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float measured_current_ma = 11;
  if (!(this->measured_current_ma() <= 0 && this->measured_current_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_protection_threshold_ma = 12;
  if (!(this->current_protection_threshold_ma() <= 0 && this->current_protection_threshold_ma() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_calibration_percent = 13;
  if (!(this->current_calibration_percent() <= 0 && this->current_calibration_percent() >= 0)) {
    total_size += 1 + 4;
  }

  // float measured_voltage_v = 14;
  if (!(this->measured_voltage_v() <= 0 && this->measured_voltage_v() >= 0)) {
    total_size += 1 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LddStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LddStatus*>(
      &from));
}

void LddStatus::MergeFrom(const LddStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.LddStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.frequency_hz() <= 0 && from.frequency_hz() >= 0)) {
    _internal_set_frequency_hz(from._internal_frequency_hz());
  }
  if (!(from.frequency_min_hz() <= 0 && from.frequency_min_hz() >= 0)) {
    _internal_set_frequency_min_hz(from._internal_frequency_min_hz());
  }
  if (!(from.frequency_max_hz() <= 0 && from.frequency_max_hz() >= 0)) {
    _internal_set_frequency_max_hz(from._internal_frequency_max_hz());
  }
  if (!(from.duration_ms() <= 0 && from.duration_ms() >= 0)) {
    _internal_set_duration_ms(from._internal_duration_ms());
  }
  if (!(from.duration_min_ms() <= 0 && from.duration_min_ms() >= 0)) {
    _internal_set_duration_min_ms(from._internal_duration_min_ms());
  }
  if (!(from.duration_max_ms() <= 0 && from.duration_max_ms() >= 0)) {
    _internal_set_duration_max_ms(from._internal_duration_max_ms());
  }
  if (!(from.current_ma() <= 0 && from.current_ma() >= 0)) {
    _internal_set_current_ma(from._internal_current_ma());
  }
  if (!(from.current_min_ma() <= 0 && from.current_min_ma() >= 0)) {
    _internal_set_current_min_ma(from._internal_current_min_ma());
  }
  if (!(from.current_max_ma() <= 0 && from.current_max_ma() >= 0)) {
    _internal_set_current_max_ma(from._internal_current_max_ma());
  }
  if (!(from.current_max_limit_ma() <= 0 && from.current_max_limit_ma() >= 0)) {
    _internal_set_current_max_limit_ma(from._internal_current_max_limit_ma());
  }
  if (!(from.measured_current_ma() <= 0 && from.measured_current_ma() >= 0)) {
    _internal_set_measured_current_ma(from._internal_measured_current_ma());
  }
  if (!(from.current_protection_threshold_ma() <= 0 && from.current_protection_threshold_ma() >= 0)) {
    _internal_set_current_protection_threshold_ma(from._internal_current_protection_threshold_ma());
  }
  if (!(from.current_calibration_percent() <= 0 && from.current_calibration_percent() >= 0)) {
    _internal_set_current_calibration_percent(from._internal_current_calibration_percent());
  }
  if (!(from.measured_voltage_v() <= 0 && from.measured_voltage_v() >= 0)) {
    _internal_set_measured_voltage_v(from._internal_measured_voltage_v());
  }
}

void LddStatus::CopyFrom(const LddStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.LddStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LddStatus::IsInitialized() const {
  return true;
}

void LddStatus::InternalSwap(LddStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LddStatus, measured_voltage_v_)
      + sizeof(LddStatus::measured_voltage_v_)
      - PROTOBUF_FIELD_OFFSET(LddStatus, frequency_hz_)>(
          reinterpret_cast<char*>(&frequency_hz_),
          reinterpret_cast<char*>(&other->frequency_hz_));
}

std::string LddStatus::GetTypeName() const {
  return "sf8xxx_nm.LddStatus";
}


// ===================================================================

class TecStatus::_Internal {
 public:
};

TecStatus::TecStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.TecStatus)
}
TecStatus::TecStatus(const TecStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&temperature_celsius_, &from.temperature_celsius_,
    static_cast<size_t>(reinterpret_cast<char*>(&external_ntc_measured_temp_celsius_) -
    reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(external_ntc_measured_temp_celsius_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.TecStatus)
}

void TecStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&temperature_celsius_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&external_ntc_measured_temp_celsius_) -
    reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(external_ntc_measured_temp_celsius_));
}

TecStatus::~TecStatus() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.TecStatus)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TecStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TecStatus::ArenaDtor(void* object) {
  TecStatus* _this = reinterpret_cast< TecStatus* >(object);
  (void)_this;
}
void TecStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TecStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TecStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.TecStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&temperature_celsius_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&external_ntc_measured_temp_celsius_) -
      reinterpret_cast<char*>(&temperature_celsius_)) + sizeof(external_ntc_measured_temp_celsius_));
  _internal_metadata_.Clear<std::string>();
}

const char* TecStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // float temperature_celsius = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          temperature_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_max_celsius = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          temp_max_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_min_celsius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          temp_min_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_max_limit_celsius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          temp_max_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float temp_min_limit_celsius = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          temp_min_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float measured_temperature_celsius = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          measured_temperature_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float measured_current_a = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          measured_current_a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float current_limit_a = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          current_limit_a_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float measured_voltage_v = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          measured_voltage_v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float calibration_percent = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          calibration_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // uint32 p_coefficient = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          p_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 i_coefficient = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          i_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 d_coefficient = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          d_coefficient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float external_ntc_lower_limit_celsius = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          external_ntc_lower_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float external_ntc_upper_limit_celsius = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          external_ntc_upper_limit_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // float external_ntc_measured_temp_celsius = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 133)) {
          external_ntc_measured_temp_celsius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TecStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.TecStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float temperature_celsius = 1;
  if (!(this->temperature_celsius() <= 0 && this->temperature_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_temperature_celsius(), target);
  }

  // float temp_max_celsius = 2;
  if (!(this->temp_max_celsius() <= 0 && this->temp_max_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_temp_max_celsius(), target);
  }

  // float temp_min_celsius = 3;
  if (!(this->temp_min_celsius() <= 0 && this->temp_min_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_temp_min_celsius(), target);
  }

  // float temp_max_limit_celsius = 4;
  if (!(this->temp_max_limit_celsius() <= 0 && this->temp_max_limit_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_temp_max_limit_celsius(), target);
  }

  // float temp_min_limit_celsius = 5;
  if (!(this->temp_min_limit_celsius() <= 0 && this->temp_min_limit_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_temp_min_limit_celsius(), target);
  }

  // float measured_temperature_celsius = 6;
  if (!(this->measured_temperature_celsius() <= 0 && this->measured_temperature_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_measured_temperature_celsius(), target);
  }

  // float measured_current_a = 7;
  if (!(this->measured_current_a() <= 0 && this->measured_current_a() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_measured_current_a(), target);
  }

  // float current_limit_a = 8;
  if (!(this->current_limit_a() <= 0 && this->current_limit_a() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_current_limit_a(), target);
  }

  // float measured_voltage_v = 9;
  if (!(this->measured_voltage_v() <= 0 && this->measured_voltage_v() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_measured_voltage_v(), target);
  }

  // float calibration_percent = 10;
  if (!(this->calibration_percent() <= 0 && this->calibration_percent() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_calibration_percent(), target);
  }

  // uint32 p_coefficient = 11;
  if (this->p_coefficient() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_p_coefficient(), target);
  }

  // uint32 i_coefficient = 12;
  if (this->i_coefficient() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_i_coefficient(), target);
  }

  // uint32 d_coefficient = 13;
  if (this->d_coefficient() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_d_coefficient(), target);
  }

  // float external_ntc_lower_limit_celsius = 14;
  if (!(this->external_ntc_lower_limit_celsius() <= 0 && this->external_ntc_lower_limit_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_external_ntc_lower_limit_celsius(), target);
  }

  // float external_ntc_upper_limit_celsius = 15;
  if (!(this->external_ntc_upper_limit_celsius() <= 0 && this->external_ntc_upper_limit_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_external_ntc_upper_limit_celsius(), target);
  }

  // float external_ntc_measured_temp_celsius = 16;
  if (!(this->external_ntc_measured_temp_celsius() <= 0 && this->external_ntc_measured_temp_celsius() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(16, this->_internal_external_ntc_measured_temp_celsius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.TecStatus)
  return target;
}

size_t TecStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.TecStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float temperature_celsius = 1;
  if (!(this->temperature_celsius() <= 0 && this->temperature_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float temp_max_celsius = 2;
  if (!(this->temp_max_celsius() <= 0 && this->temp_max_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float temp_min_celsius = 3;
  if (!(this->temp_min_celsius() <= 0 && this->temp_min_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float temp_max_limit_celsius = 4;
  if (!(this->temp_max_limit_celsius() <= 0 && this->temp_max_limit_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float temp_min_limit_celsius = 5;
  if (!(this->temp_min_limit_celsius() <= 0 && this->temp_min_limit_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float measured_temperature_celsius = 6;
  if (!(this->measured_temperature_celsius() <= 0 && this->measured_temperature_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float measured_current_a = 7;
  if (!(this->measured_current_a() <= 0 && this->measured_current_a() >= 0)) {
    total_size += 1 + 4;
  }

  // float current_limit_a = 8;
  if (!(this->current_limit_a() <= 0 && this->current_limit_a() >= 0)) {
    total_size += 1 + 4;
  }

  // float measured_voltage_v = 9;
  if (!(this->measured_voltage_v() <= 0 && this->measured_voltage_v() >= 0)) {
    total_size += 1 + 4;
  }

  // float calibration_percent = 10;
  if (!(this->calibration_percent() <= 0 && this->calibration_percent() >= 0)) {
    total_size += 1 + 4;
  }

  // uint32 p_coefficient = 11;
  if (this->p_coefficient() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_p_coefficient());
  }

  // uint32 i_coefficient = 12;
  if (this->i_coefficient() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_i_coefficient());
  }

  // uint32 d_coefficient = 13;
  if (this->d_coefficient() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_d_coefficient());
  }

  // float external_ntc_lower_limit_celsius = 14;
  if (!(this->external_ntc_lower_limit_celsius() <= 0 && this->external_ntc_lower_limit_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float external_ntc_upper_limit_celsius = 15;
  if (!(this->external_ntc_upper_limit_celsius() <= 0 && this->external_ntc_upper_limit_celsius() >= 0)) {
    total_size += 1 + 4;
  }

  // float external_ntc_measured_temp_celsius = 16;
  if (!(this->external_ntc_measured_temp_celsius() <= 0 && this->external_ntc_measured_temp_celsius() >= 0)) {
    total_size += 2 + 4;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TecStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TecStatus*>(
      &from));
}

void TecStatus::MergeFrom(const TecStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.TecStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.temperature_celsius() <= 0 && from.temperature_celsius() >= 0)) {
    _internal_set_temperature_celsius(from._internal_temperature_celsius());
  }
  if (!(from.temp_max_celsius() <= 0 && from.temp_max_celsius() >= 0)) {
    _internal_set_temp_max_celsius(from._internal_temp_max_celsius());
  }
  if (!(from.temp_min_celsius() <= 0 && from.temp_min_celsius() >= 0)) {
    _internal_set_temp_min_celsius(from._internal_temp_min_celsius());
  }
  if (!(from.temp_max_limit_celsius() <= 0 && from.temp_max_limit_celsius() >= 0)) {
    _internal_set_temp_max_limit_celsius(from._internal_temp_max_limit_celsius());
  }
  if (!(from.temp_min_limit_celsius() <= 0 && from.temp_min_limit_celsius() >= 0)) {
    _internal_set_temp_min_limit_celsius(from._internal_temp_min_limit_celsius());
  }
  if (!(from.measured_temperature_celsius() <= 0 && from.measured_temperature_celsius() >= 0)) {
    _internal_set_measured_temperature_celsius(from._internal_measured_temperature_celsius());
  }
  if (!(from.measured_current_a() <= 0 && from.measured_current_a() >= 0)) {
    _internal_set_measured_current_a(from._internal_measured_current_a());
  }
  if (!(from.current_limit_a() <= 0 && from.current_limit_a() >= 0)) {
    _internal_set_current_limit_a(from._internal_current_limit_a());
  }
  if (!(from.measured_voltage_v() <= 0 && from.measured_voltage_v() >= 0)) {
    _internal_set_measured_voltage_v(from._internal_measured_voltage_v());
  }
  if (!(from.calibration_percent() <= 0 && from.calibration_percent() >= 0)) {
    _internal_set_calibration_percent(from._internal_calibration_percent());
  }
  if (from.p_coefficient() != 0) {
    _internal_set_p_coefficient(from._internal_p_coefficient());
  }
  if (from.i_coefficient() != 0) {
    _internal_set_i_coefficient(from._internal_i_coefficient());
  }
  if (from.d_coefficient() != 0) {
    _internal_set_d_coefficient(from._internal_d_coefficient());
  }
  if (!(from.external_ntc_lower_limit_celsius() <= 0 && from.external_ntc_lower_limit_celsius() >= 0)) {
    _internal_set_external_ntc_lower_limit_celsius(from._internal_external_ntc_lower_limit_celsius());
  }
  if (!(from.external_ntc_upper_limit_celsius() <= 0 && from.external_ntc_upper_limit_celsius() >= 0)) {
    _internal_set_external_ntc_upper_limit_celsius(from._internal_external_ntc_upper_limit_celsius());
  }
  if (!(from.external_ntc_measured_temp_celsius() <= 0 && from.external_ntc_measured_temp_celsius() >= 0)) {
    _internal_set_external_ntc_measured_temp_celsius(from._internal_external_ntc_measured_temp_celsius());
  }
}

void TecStatus::CopyFrom(const TecStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.TecStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TecStatus::IsInitialized() const {
  return true;
}

void TecStatus::InternalSwap(TecStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TecStatus, external_ntc_measured_temp_celsius_)
      + sizeof(TecStatus::external_ntc_measured_temp_celsius_)
      - PROTOBUF_FIELD_OFFSET(TecStatus, temperature_celsius_)>(
          reinterpret_cast<char*>(&temperature_celsius_),
          reinterpret_cast<char*>(&other->temperature_celsius_));
}

std::string TecStatus::GetTypeName() const {
  return "sf8xxx_nm.TecStatus";
}


// ===================================================================

class DriverStateInfo::_Internal {
 public:
};

DriverStateInfo::DriverStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.DriverStateInfo)
}
DriverStateInfo::DriverStateInfo(const DriverStateInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&is_powered_on_, &from.is_powered_on_,
    static_cast<size_t>(reinterpret_cast<char*>(&interlock_is_denied_) -
    reinterpret_cast<char*>(&is_powered_on_)) + sizeof(interlock_is_denied_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.DriverStateInfo)
}

void DriverStateInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_powered_on_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&interlock_is_denied_) -
    reinterpret_cast<char*>(&is_powered_on_)) + sizeof(interlock_is_denied_));
}

DriverStateInfo::~DriverStateInfo() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.DriverStateInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void DriverStateInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void DriverStateInfo::ArenaDtor(void* object) {
  DriverStateInfo* _this = reinterpret_cast< DriverStateInfo* >(object);
  (void)_this;
}
void DriverStateInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DriverStateInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DriverStateInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.DriverStateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&is_powered_on_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&interlock_is_denied_) -
      reinterpret_cast<char*>(&is_powered_on_)) + sizeof(interlock_is_denied_));
  _internal_metadata_.Clear<std::string>();
}

const char* DriverStateInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool is_powered_on = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          is_powered_on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool is_started = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          is_started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool current_set_is_internal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          current_set_is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool enable_is_internal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          enable_is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ext_ntc_interlock_is_denied = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ext_ntc_interlock_is_denied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool interlock_is_denied = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          interlock_is_denied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DriverStateInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.DriverStateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_powered_on = 1;
  if (this->is_powered_on() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_powered_on(), target);
  }

  // bool is_started = 2;
  if (this->is_started() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_started(), target);
  }

  // bool current_set_is_internal = 3;
  if (this->current_set_is_internal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_current_set_is_internal(), target);
  }

  // bool enable_is_internal = 4;
  if (this->enable_is_internal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_enable_is_internal(), target);
  }

  // bool ext_ntc_interlock_is_denied = 5;
  if (this->ext_ntc_interlock_is_denied() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_ext_ntc_interlock_is_denied(), target);
  }

  // bool interlock_is_denied = 6;
  if (this->interlock_is_denied() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_interlock_is_denied(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.DriverStateInfo)
  return target;
}

size_t DriverStateInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.DriverStateInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool is_powered_on = 1;
  if (this->is_powered_on() != 0) {
    total_size += 1 + 1;
  }

  // bool is_started = 2;
  if (this->is_started() != 0) {
    total_size += 1 + 1;
  }

  // bool current_set_is_internal = 3;
  if (this->current_set_is_internal() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_is_internal = 4;
  if (this->enable_is_internal() != 0) {
    total_size += 1 + 1;
  }

  // bool ext_ntc_interlock_is_denied = 5;
  if (this->ext_ntc_interlock_is_denied() != 0) {
    total_size += 1 + 1;
  }

  // bool interlock_is_denied = 6;
  if (this->interlock_is_denied() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DriverStateInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const DriverStateInfo*>(
      &from));
}

void DriverStateInfo::MergeFrom(const DriverStateInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.DriverStateInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.is_powered_on() != 0) {
    _internal_set_is_powered_on(from._internal_is_powered_on());
  }
  if (from.is_started() != 0) {
    _internal_set_is_started(from._internal_is_started());
  }
  if (from.current_set_is_internal() != 0) {
    _internal_set_current_set_is_internal(from._internal_current_set_is_internal());
  }
  if (from.enable_is_internal() != 0) {
    _internal_set_enable_is_internal(from._internal_enable_is_internal());
  }
  if (from.ext_ntc_interlock_is_denied() != 0) {
    _internal_set_ext_ntc_interlock_is_denied(from._internal_ext_ntc_interlock_is_denied());
  }
  if (from.interlock_is_denied() != 0) {
    _internal_set_interlock_is_denied(from._internal_interlock_is_denied());
  }
}

void DriverStateInfo::CopyFrom(const DriverStateInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.DriverStateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DriverStateInfo::IsInitialized() const {
  return true;
}

void DriverStateInfo::InternalSwap(DriverStateInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DriverStateInfo, interlock_is_denied_)
      + sizeof(DriverStateInfo::interlock_is_denied_)
      - PROTOBUF_FIELD_OFFSET(DriverStateInfo, is_powered_on_)>(
          reinterpret_cast<char*>(&is_powered_on_),
          reinterpret_cast<char*>(&other->is_powered_on_));
}

std::string DriverStateInfo::GetTypeName() const {
  return "sf8xxx_nm.DriverStateInfo";
}


// ===================================================================

class TecStateInfo::_Internal {
 public:
};

TecStateInfo::TecStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.TecStateInfo)
}
TecStateInfo::TecStateInfo(const TecStateInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&is_started_, &from.is_started_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_is_internal_) -
    reinterpret_cast<char*>(&is_started_)) + sizeof(enable_is_internal_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.TecStateInfo)
}

void TecStateInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_started_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_is_internal_) -
    reinterpret_cast<char*>(&is_started_)) + sizeof(enable_is_internal_));
}

TecStateInfo::~TecStateInfo() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.TecStateInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void TecStateInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TecStateInfo::ArenaDtor(void* object) {
  TecStateInfo* _this = reinterpret_cast< TecStateInfo* >(object);
  (void)_this;
}
void TecStateInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TecStateInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TecStateInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.TecStateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&is_started_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&enable_is_internal_) -
      reinterpret_cast<char*>(&is_started_)) + sizeof(enable_is_internal_));
  _internal_metadata_.Clear<std::string>();
}

const char* TecStateInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool is_started = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          is_started_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool temp_set_is_internal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          temp_set_is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool enable_is_internal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          enable_is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TecStateInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.TecStateInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool is_started = 1;
  if (this->is_started() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_started(), target);
  }

  // bool temp_set_is_internal = 2;
  if (this->temp_set_is_internal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_temp_set_is_internal(), target);
  }

  // bool enable_is_internal = 3;
  if (this->enable_is_internal() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_enable_is_internal(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.TecStateInfo)
  return target;
}

size_t TecStateInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.TecStateInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool is_started = 1;
  if (this->is_started() != 0) {
    total_size += 1 + 1;
  }

  // bool temp_set_is_internal = 2;
  if (this->temp_set_is_internal() != 0) {
    total_size += 1 + 1;
  }

  // bool enable_is_internal = 3;
  if (this->enable_is_internal() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TecStateInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const TecStateInfo*>(
      &from));
}

void TecStateInfo::MergeFrom(const TecStateInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.TecStateInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.is_started() != 0) {
    _internal_set_is_started(from._internal_is_started());
  }
  if (from.temp_set_is_internal() != 0) {
    _internal_set_temp_set_is_internal(from._internal_temp_set_is_internal());
  }
  if (from.enable_is_internal() != 0) {
    _internal_set_enable_is_internal(from._internal_enable_is_internal());
  }
}

void TecStateInfo::CopyFrom(const TecStateInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.TecStateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TecStateInfo::IsInitialized() const {
  return true;
}

void TecStateInfo::InternalSwap(TecStateInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TecStateInfo, enable_is_internal_)
      + sizeof(TecStateInfo::enable_is_internal_)
      - PROTOBUF_FIELD_OFFSET(TecStateInfo, is_started_)>(
          reinterpret_cast<char*>(&is_started_),
          reinterpret_cast<char*>(&other->is_started_));
}

std::string TecStateInfo::GetTypeName() const {
  return "sf8xxx_nm.TecStateInfo";
}


// ===================================================================

class LockStatusInfo::_Internal {
 public:
};

LockStatusInfo::LockStatusInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sf8xxx_nm.LockStatusInfo)
}
LockStatusInfo::LockStatusInfo(const LockStatusInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&interlock_active_, &from.interlock_active_,
    static_cast<size_t>(reinterpret_cast<char*>(&tec_self_heat_) -
    reinterpret_cast<char*>(&interlock_active_)) + sizeof(tec_self_heat_));
  // @@protoc_insertion_point(copy_constructor:sf8xxx_nm.LockStatusInfo)
}

void LockStatusInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&interlock_active_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tec_self_heat_) -
    reinterpret_cast<char*>(&interlock_active_)) + sizeof(tec_self_heat_));
}

LockStatusInfo::~LockStatusInfo() {
  // @@protoc_insertion_point(destructor:sf8xxx_nm.LockStatusInfo)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void LockStatusInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LockStatusInfo::ArenaDtor(void* object) {
  LockStatusInfo* _this = reinterpret_cast< LockStatusInfo* >(object);
  (void)_this;
}
void LockStatusInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LockStatusInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LockStatusInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sf8xxx_nm.LockStatusInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&interlock_active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tec_self_heat_) -
      reinterpret_cast<char*>(&interlock_active_)) + sizeof(tec_self_heat_));
  _internal_metadata_.Clear<std::string>();
}

const char* LockStatusInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool interlock_active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          interlock_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ld_over_current = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ld_over_current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ld_overheat = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ld_overheat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ext_ntc_interlock_active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ext_ntc_interlock_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool tec_error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          tec_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool tec_self_heat = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          tec_self_heat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LockStatusInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sf8xxx_nm.LockStatusInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool interlock_active = 1;
  if (this->interlock_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_interlock_active(), target);
  }

  // bool ld_over_current = 2;
  if (this->ld_over_current() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_ld_over_current(), target);
  }

  // bool ld_overheat = 3;
  if (this->ld_overheat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_ld_overheat(), target);
  }

  // bool ext_ntc_interlock_active = 4;
  if (this->ext_ntc_interlock_active() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_ext_ntc_interlock_active(), target);
  }

  // bool tec_error = 5;
  if (this->tec_error() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_tec_error(), target);
  }

  // bool tec_self_heat = 6;
  if (this->tec_self_heat() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_tec_self_heat(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sf8xxx_nm.LockStatusInfo)
  return target;
}

size_t LockStatusInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sf8xxx_nm.LockStatusInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool interlock_active = 1;
  if (this->interlock_active() != 0) {
    total_size += 1 + 1;
  }

  // bool ld_over_current = 2;
  if (this->ld_over_current() != 0) {
    total_size += 1 + 1;
  }

  // bool ld_overheat = 3;
  if (this->ld_overheat() != 0) {
    total_size += 1 + 1;
  }

  // bool ext_ntc_interlock_active = 4;
  if (this->ext_ntc_interlock_active() != 0) {
    total_size += 1 + 1;
  }

  // bool tec_error = 5;
  if (this->tec_error() != 0) {
    total_size += 1 + 1;
  }

  // bool tec_self_heat = 6;
  if (this->tec_self_heat() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LockStatusInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const LockStatusInfo*>(
      &from));
}

void LockStatusInfo::MergeFrom(const LockStatusInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sf8xxx_nm.LockStatusInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.interlock_active() != 0) {
    _internal_set_interlock_active(from._internal_interlock_active());
  }
  if (from.ld_over_current() != 0) {
    _internal_set_ld_over_current(from._internal_ld_over_current());
  }
  if (from.ld_overheat() != 0) {
    _internal_set_ld_overheat(from._internal_ld_overheat());
  }
  if (from.ext_ntc_interlock_active() != 0) {
    _internal_set_ext_ntc_interlock_active(from._internal_ext_ntc_interlock_active());
  }
  if (from.tec_error() != 0) {
    _internal_set_tec_error(from._internal_tec_error());
  }
  if (from.tec_self_heat() != 0) {
    _internal_set_tec_self_heat(from._internal_tec_self_heat());
  }
}

void LockStatusInfo::CopyFrom(const LockStatusInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sf8xxx_nm.LockStatusInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LockStatusInfo::IsInitialized() const {
  return true;
}

void LockStatusInfo::InternalSwap(LockStatusInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LockStatusInfo, tec_self_heat_)
      + sizeof(LockStatusInfo::tec_self_heat_)
      - PROTOBUF_FIELD_OFFSET(LockStatusInfo, interlock_active_)>(
          reinterpret_cast<char*>(&interlock_active_),
          reinterpret_cast<char*>(&other->interlock_active_));
}

std::string LockStatusInfo::GetTypeName() const {
  return "sf8xxx_nm.LockStatusInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sf8xxx_nm
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::DriverCommand* Arena::CreateMaybeMessage< ::sf8xxx_nm::DriverCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::DriverCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::DriverResponse* Arena::CreateMaybeMessage< ::sf8xxx_nm::DriverResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::DriverResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::ConfigureCommand* Arena::CreateMaybeMessage< ::sf8xxx_nm::ConfigureCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::ConfigureCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::LddSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::LddSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::LddSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::TecSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::TecSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::TecSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::PidSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::PidSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::PidSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::NtcInterlockSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::NtcInterlockSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::NtcInterlockSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::DriverStateSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::DriverStateSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::DriverStateSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::TecStateSettings* Arena::CreateMaybeMessage< ::sf8xxx_nm::TecStateSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::TecStateSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::RequestCommand* Arena::CreateMaybeMessage< ::sf8xxx_nm::RequestCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::RequestCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::ActionCommand* Arena::CreateMaybeMessage< ::sf8xxx_nm::ActionCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::ActionCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::LddStatus* Arena::CreateMaybeMessage< ::sf8xxx_nm::LddStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::LddStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::TecStatus* Arena::CreateMaybeMessage< ::sf8xxx_nm::TecStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::TecStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::DriverStateInfo* Arena::CreateMaybeMessage< ::sf8xxx_nm::DriverStateInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::DriverStateInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::TecStateInfo* Arena::CreateMaybeMessage< ::sf8xxx_nm::TecStateInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::TecStateInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::sf8xxx_nm::LockStatusInfo* Arena::CreateMaybeMessage< ::sf8xxx_nm::LockStatusInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sf8xxx_nm::LockStatusInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
